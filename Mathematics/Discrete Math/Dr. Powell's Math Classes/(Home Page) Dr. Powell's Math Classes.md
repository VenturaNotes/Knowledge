---
Source:
  - https://www.youtube.com/playlist?list=PL0L_SisGP4hO9IQnYGPRJGwj7GEaHBChE
Length: 14 hours, 59 minutes, 2 seconds
tags:
  - status/incomplete
  - type/playlist
Reviewed: false
---
- Complete
	- [[(1) Discrete Mathematics Textbook and Playlist]]
	- [[(2) Simple Examples of Non discrete and Discrete Sets]]
- Incomplete
	- [[(3) The Definition of a Function]]
	- [[(4) Induced Image and Preimage Function]]
	- [[(5) Fibers of a Function]]
	- [[(6) Fiber Box Diagram]]
	- [[(7) Functions, Fibers, Injectivity, Surjectivity]]
	- [[(8) Injectivity, Surjectivity and Bijectivity]]
	- [[(9) A Beginning View of Power Sets]]
	- [[(10) Pigeon Hole Principle]]
	- [[(11) Pigeon Hole Principle]]
	- [[(12) Functions Break into Merging and Relabeling]]
	- [[(13) Fiber Nesting and Commutative Diagrams]]
	- [[(14) Function Induction by Comparing Fiber Partitions]]
	- [[(15) Example of Inducing Function by comparing fiber partitions]]
	- [[(16) Functions that Preserve Structure]]
	- [[(17) Preservation of Identities and Inverses]]
	- [[(18) Finding Fibers of Addition Preserving Map Example]]
	- [[(19) Polynomial Ring Partition that preserves Addition and Multiplication]]
	- [[(20) Introduction to Modular Arithmetic]]
	- [[(21) Fast Computation with Modular Arithmetic]]
	- [[(22) Posets and Hasse Diagrams]]
	- [[(23) Merges that preserve Union and Intersection]]
	- [[(24) Distributive Property of Union and Intersection]]
	- [[(25) Complements and Duality in a Power Set]]
	- [[(26) Meet and Join on a Poset]]
	- [[(27) Boolean Algebraic Expressions as Subsets]]
	- [[(28) Calculate logic and and or on a simple Hasse diagram]]
	- [[(29) Merges that make sandwich swallowing work]]
	- [[(30) Boolean Optimization from Disjunctive Normal Form]]
	- [[(31) Boolean Optimization with Conjunctive Normal Form]]
	- [[(32) 2 Ways of Converting from Disjunctive to Conjunctive]]
	- [[(33) Proof by Contradiction]]
	- [[(34) Proof by Induction]]
	- [[(35) Example of Thinking Through an Induction Proof]]
	- [[(36) Cantor's Diagonal Argument and Generalization]]
	- [[(37) Shroeder Bernstein]]
	- [[(38) Well Ordering]]
	- [[(39) Zorn's Lemma]]
	- [[(40) Polynomial Modular Arithmetic Reduction Example 1]]
	- [[(41) Taylor Expansion of Polynomial Introduction]]
	- [[(42) Use Taylor Series with Polynomial Modular Arithmetic]]
	- [[(43) Pascal's Triangle and Binomial Coefficients]]
	- [[(44) Polynomial Committees Example 1]]
	- [[(45) Polynomial Counting With a Die]]
	- [[(46) Pascal's Pyramid]]
	- [[(47) A Cool Binomial Coefficient Identity]]
	- [[(48) Using Binomial Coefficients to Find a Non recursive Formula]]
	- [[(49) Target Inversion Example 1]]
	- [[(50) Target Inversion Example 2]]
	- [[(51) Target Inversion Example 3]]
	- [[(52) Finding an Inverse Using the Euclidean Algorithm]]
	- [[(53) Polynomial Inverse in a mod]]
	- [[(54) Series Inverse]]
	- [[(55) Cycle Notation for Permutations]]
	- [[(56) Decomposing Permutations into Transpositions]]
	- [[(57) Inverses of Permutations]]
	- [[(58) Permutations Often Do Not Commute]]
	- [[(59) Even and Odd Permutations]]
	- [[(60) Requirements for a Group Table]]
	- [[(61) Dihedral Arithmetic]]
	- [[(62) Mod Arithmetic in S4]]
	- [[(63) Configurations of a Bracelet]]
	- [[(64) Size of Group as an Exponent]]
	- [[(65) Exponents in Modular Arithmetic]]
	- [[(66) Multiplicative Inversion by Powers]]
	- [[(67) Group Preserving Digraph Structure]]
	- [[(68) Associativity in Geometry]]
	- [[(69) Solving an Elliptic Curve Puzzle]]
	- [[(70) Well defined Group Map Example 1]]
	- [[(71) Well defined Group Map Example 2]]
	- [[(72) Well defined Group Map Example 3]]
	- [[(73) Outside Multiplication Example]]
	- [[(74) Outside Multiplication as Exponentiation Example 2]]
	- [[(75) Outside Multiplication as Encryption and Decryption]]
	- [[(76) Solving System With 2 Congruences]]
	- [[(77) Divisibility via Module Maps]]
	- [[(78) Matrix Notation for Map between 2 free Z Modules]]
	- [[(79) Matrix Multiplication as Function Composition]]
	- [[(80) Solving a System of 3 Congruences]]
	- [[(81) RSACryptography]]
	- [[(82) Euler Phi Function]]
	- [[(83) Mobius Matrix on a Poset]]
	- [[(84) Mobius Function and Counting Primitive Bit Strings]]
	- [[(85) The Arithmetic Mobius Function and Posets]]
	- [[(86) Mobius Maps on Power Sets and Derangments]]
	- [[(87) Introduction to the Adjacency Matrix]]
	- [[(88) Visually Seeing Powers of the Adjacency Matrix]]
	- [[(89) Adjacency Matrices by Rows]]
	- [[(90) Adjacency Matrices and Permutations]]
	- [[(91) Poset Properties Seen in an Adjacency Matrix]]
	- [[(92) Oriented Incidence Matrix Example]]
	- [[(93) Smith Normal Form Example]]
	- [[(94) Using Smith Normal Form to find vectors that span the kernel]]
	- [[(95) Using Smith Normal Form to Count Cosets]]
	- [[(96) Relationship between Kernel and Injectivity]]
	- [[(97) Injective and Surjective from Smith Normal Form]]
	- [[(98) Determinant From Sliding]]
	- [[(99) Kitty-Corner Determinant]]
	- [[(100) Area in High Dimensions]]
	- [[(101) Inverse of a Matrix by Determinants]]
	- [[(102) Coset Syndrome Example]]
	- [[(103) Vector Projection From Splitting Map]]
	- [[(104) Counting the Number of Spanning Trees]]
	- [[(105) Determining Connected Components from Laplacian]]
	- [[(106) Euler's Characteristic Formula from Incidence]]
	- [[(107) Trees, Forests and Incidence]]
	- [[(108) A helpful planar inequality]]
	- [[(109) 6 Colors are Enough]]
	- [[(110) Condition for a Hamiltonian Circuit]]
	- [[(111) Proof that K5 is nonplanar]]
	- [[(112) Minimum degree of 5]]
	- [[(113) Even Vertex Degrees and Removing an Edge]]
	- [[(114) Euler Circuit Proof]]
	- [[(115) A Matrix as a Scalar]]
	- [[(116) Using Eigenvectors and Eigenvalues to find the nth power of a Matrix]]
	- [[(117) Recursion with Matrix Powers Example 1]]
	- [[(118) Making a Nonhomogeneous Recurrence Homogeneous Part 1]]
	- [[(119) Making a Nonhomogeneous Recurrence Homogeneous Part 2]]
	- [[(120) Quick Introduction to Big O Notation]]
	- [[(121) limsup]]
	- [[(122) Complexity of Sorting]]
	- [[(123) Breadth versus Depth First Searching]]
	- [[(124) Kruskal's Algorithm]]
	- [[(125) Prim's Algorithm]]
	- [[(126) Dijkstra's Algorithm]]
	- [[(127) Example of finding primitive root mod p n for odd p]]