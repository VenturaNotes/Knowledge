---
Source:
  - https://www.youtube.com/watch?v=YcKf7BT8v8Y
Reviewed: false
---
- ![[Screenshot 2024-11-27 at 3.19.30 AM.png]]
	- Introduction
		- Today we're going to be talking about how to make an MMO video game and this is pretty cool. I mean i've seen some uh, some videos on this, and actually the way i'm going to present is based off a research paper that conflicts those a little bit and has kind of nice twist so let's get into it and start doing the functional requirements. 
	- MMO Video Game (Functional Requirements)
		- Description
			- Online battle royale game (Fortnite, PubG)
		- Okay, I mean the functional requirements are pretty simple for this one. All we're really going to be doing is creating an online real-time battle royale game. You may have played PubG or Fortnite or COD Warzone. All that concept, just a lot of players, one game, you know it's not only three or four people, it's not a turn-based game. Anyone can move at the same time. Anyone could shoot at the same time, and as a result, we have to be careful of how we're going to order events, how we make sure that players have a consistent state between them and as a result, this is kind of a tough technical problem 
	- MMO Video Game (Capacity Estimates)
		- Description
			- 1,000 players per lobby
			- 10,000 stateful objects
		- In terms of estimating the capacity of our system, let's say we have say up to a thousand players in a single game session, and not only are there players that we have to keep track of and the state of them such as you know their location or their health but in addition we have objects that we have to keep track of and all of these games, there are things that you can manipulate like vehicles, you can break down walls or shoot walls, you can you know order air strikes or something so there's a lot more to keep track of than just players and keep that in mind because it's going to make things tougher to scale out  
	- MMO Video Game (API Design)
		- Description
			- findMatch(userId)
			- doAction(userId, action)
		- In terms of our API design, I'm gonna think of two for now. They're obviously gonna be a whole lot more in an actual game but let's focus on these two. The first one is just going to be to find ourselves a game. If you are an individual player, you're just going to find a game based on your user id and hopefully the game will match you up with people who are geographically located close to you so you can get low latency. In addition, there's also going to be a way to be able to send events basically to the game servers to say oh, I want to move my character this way, I want to shoot you know at this location, etc, etc. So there's going to be some end point to do an event, but we'll touch upon that more later because perhaps it would be best if we didn't do that through a traditional rest endpoint and use some sort of other technology. 
	- MMO Video Game (Database Schema)
		- Description
			- playerLocations
			- playerItems
			- playerHealth
			- objectLocations
			- objectHealth
		- In terms of a database schema, basically the premise is as follows. Obviously we want to be able to persist our game state somewhere. This is important in terms of just you know metrics and logging. It's important in terms of fault tolerance and you know, you can't have it where basically only a couple of players are you know persisting the game state locally, it needs to be in the cloud for a variety of reasons which we'll talk about in a bit  
- ![[Screenshot 2024-11-27 at 3.41.41 AM.png]]
	- MMO Video Game (Architectural Overview)
		- Okay so let's talk about the actual architecture of a system like this, and what we can do in order to scale it out over the many users that we're going to be having playing our game. So first of all, basically we know that we're going to be matching a bunch of given players to one game. That's basically what we predicated this on. We said up to a thousand players in a given lobby. Of course it's going to be very useful if all of those can be located similarly to one another. For example, all in the northwest of the united states or all in china or all in India or something, and that will decrease latency but in addition to that, another thing we could do that would make things useful is you know, make sure to only use dedicated servers for basically lobbies in the same physical location and that way we can kind of shard out certain game lobbies and it'll help to kind of improve performance but that's kind of an aside because we're going to be talking about sharding in a different context in a little bit. So you may be thinking first off, if I asked you to design a video game naively, well isn't this kind of like a zoom call? Couldn't we effectively do like a peer-to-peer communication and that would be an ideal scenario. Well technically you could, but there's a lot of problems with that and the main one if you think about it, is cheating. Let's say you and I are communicating directly and we're both playing you know a shooting game like CS:GO. If you aren't able to kind of verify that a given move is correct, I can basically just teleport around on the map and change the game state on my client and then send that to you and you have no choice but to believe it. At least if we have a central server between us that's verifying the state and basically saying, oh this checks out based on what I know about your character before, then you know it's more likely that i will be caught if i'm cheating. That's not to say that it's 100% effective. Obviously there's still ways that you can cheat with a centralized server involved, however, it's going to greatly decrease the risk that i just blatantly manipulate the game state. Okay, so we know that we have this central server and we know that given we're having a huge massive video game here, we want to keep latency as low as humanly possible. So what can we actually do to do this? Well this is actually where something like our stock exchange video comes in. Actually it's kind of similar in many significant ways. One of which is that all of our states can and should be kept in memory. Obviously that means we want to basically be decoupling every single aspect of the logic from the game server except holding that game state and additionally it means that you know we're going to have to do some smart things in order to kind of persist our state because if our game server is to crash, we don't want the entire state to be lost, right. We want to be able to have a fault tolerant video game, and then in addition to kind of working with memory, another optimization that we can do in order to make sure that basically the latency is as low as possible is instead of using TCP, we can use UDP and I've spoken about this in the past but generally, the gist is that TCP takes much longer as it requires you know round trips over the network and additionally it has measures like congestion control and flow control whereas UDP, you're basically just sending packets indiscriminately. So now from here the question is, what is it that the client is actually sending to that centralized game state server, and there are a couple of options. So the first one is they basically send the event itself where an event could be something like a key press, you know, in most video games, it's WASD to move forward, left, down, or right and you know let's say i say to the centralized server, I just press w on my server and then the centralized server would go to all the other players in the game. Jordan pressed W. And they would then all basically replicate that and have my character press W in their local instance, so that could work you know. It would be the case that all the characters would be pressing the same keys throughout, however there's a fundamental issue with this and that is that even though they know what key i pressed, they don't know the exact time that i pressed it and so if they have basically a list of keys that i pressed but they don't exactly know you know how many seconds it was between when i pressed "W" and when i pressed "A" because you know there's network latency in between those, there's no possible way for them to end up in the same exact state that i ended up in. Um you know, like they might move forward for longer on their screen before you know moving left and that's the point. So what we actually have to do instead of basically just sending the key presses is we have to actually send the entire state of the relevant objects that we're changing or possibly even more than that. So this is obviously problematic in the sense that um when you send the state of the game and there are tons of objects in this game, I said up to ten thousand, that's going to be a huge penalty over the network and we can incur a lot of latency there. So what can we do to kind of reduce this. Well first of all, we can use something like a serialization framework. I've talked about protocol buffers in the past. I've talked about thrift. I've talked about Avro. Basically you're taking your data and kind of compressing it in a way such that it reduces the network payload. 
		- (1) In addition to that, what we can further do is actually go ahead and shard the video game map, so what does this mean? It means that basically kind of like a geohash that we've discussed in the past, we take the entire huge video game map that can hold thousands of players, and we split it into separate servers where each server is holding only a smaller portion of the map, and so every single player is only responsible for communicating its state updates with the part of the map region that it actually belongs in. We can call that its region server.
		- So the only server that the player is going to directly communicate to is the region server and the thing that they're going to be communicating is this basically compressed state of all the objects that they're capable of seeing in the region. So basically we've now established this concept of region servers which allows us to shard up our huge game map into all of these smaller pieces to increase the throughput for basically all of these players because now we're not only basically forcing all the players to communicate with just one server which would be overloaded, but this comes with a variety of conflicts and kind of challenges that we have to deal with in the following sense. So basically, every single player is only going to be sending state updates to the server that they're in. However, it's not necessarily going to be the case that they're only going to be receiving state updates from the server that they're in. The reasoning for this is as follows and i'll kind of put a diagram up on the screen to explain it. 
		- (2) Every single player or at least you know typically it's video game dependent, but is going to basically have some radius around them where they're able to see that area and interact with things within that radius, but what if they're at basically the border that a region server covers and right now basically the territory that they're in is right next to the start of another region server. Well it can't be the case that if they're not hearing from that second region server, someone could be right next to them and they won't even know it because basically the other region server isn't going to tell them about that state update, so once they get close to this border there has to be some methodology of communication between region servers that allows basically the region server that the player is not currently in to communicate to them and there are a couple ways of going about this. 
		- So the first is to actually have some sort of centralized server, right. And the centralized server we could call it a world server and that's how i've seen it addressed in other systems design videos but personally i don't think this is the greatest option and i'll explain why in a little bit. The centralized server is going to do the following. It is going to basically act as a complicated load balancer where it stores all the states of the individual players and then for those individual players once a player gets close to the border, it'll basically say okay both of you servers on this border have to start communicating back to the player. Now that's doable but it basically means that now all the player writes have to go through the centralized server and that centralized server can get overloaded. So what's another option is to basically keep this activity decentralized. Basically the region server that currently contains the player has to contact with the other region server on the other end of the adjacent border and tell the other region server, hey, for the points inside this player's range of interest which is a radius, make sure to also be actively sending UDP updates to the player so that they can keep their state intact for that part of the region, and then that way the player is able to kind of get their whole radius of interest updated. Okay so we've now kind of covered how a player can kind of see things across the border of region servers but it's a little bit more complicated than that because not only can players see across borders but they can also actually travel across borders, and this is where things get a little complex. So the nice thing about having one server where all the writes go to, is that writes are ordered, right? We can get an entire sequence of writes and we always know kind of what comes first, right? So if we just add one single server, let's say me and you are looking at one another in the video game and we're both trying to shoot each other. The server is going to decide which bullet came first, however, now let's imagine that you and I are on the other ends of a region server border and we both click the shoot button, what if it was the case that basically my region server said i shot first, your region server said you shot first. Well then we're going to have a problem and we have a conflict and we can't have a conflict because we said that every single player has to see the same state for a game, so the only really option that we have here is to actually introduce some sort of locking. So anytime that there is basically cross region server activity whether that's a player moving across a region server, an object that you know is not a player moving across a region server, or even if there's just like a bomb explosion and it hits an area that spans two region servers, basically there is going to have to be a lock that is grabbed by one of the region servers and kind of held on the other region server and that way they can make sure that no two events are going to be affecting that area at once and then you won't have an issue in determining the actual ordering of events. Everyone will see something consistent (If player A (region 1) shoots player B (region 2), region 1 gets a lock on player B from region 2 so that player 2 cannot shoot and hit player 1). Otherwise, we would have a problem. Now you may say to yourself oh Jordan, well in systems design interviews, you should be avoiding locks as much as possible. You know, they're basically the bane of our existence. They're super slow, and they're inefficient and they're not that scalable and the truth of the matter is, that is correct unfortunately but in this case it's still actually a better option than dealing with one centralized server because it means you're not limited to the throughput of one machine. Additionally and more importantly, these locks are relatively low latency compared to the latency that it takes to get from one of the region servers to the player. All the region servers are probably going to be within the same data center and because they're in the same data center, it means that basically the latency between them is going to be super low and the latency between you know the data center and a player and god knows where in their mom's basement is going to be pretty high, and so even though locking is not great, when comparing those two latencies between the servers and a server and player, that lock is not going to be too jittery but what if we did actually encounter a latency spike between servers. What is it that we would actually have to do on kind of the client side to go ahead and mask that? Well actually what games will do here is something known as interpolation. An interpolation is basically just the front end or basically our video game on our graphics card guessing what's going to happen next without receiving a state update. So let's say i'm traveling forward at 5 miles an hour. If i don't hear a state update from the server saying i've made a right turn, the game is just going to assume that i'm still traveling forward at five miles per hour and for the most part, they're probably going to be right. I probably didn't click a key to change my direction, obviously sometimes i will have and then you're going to get that lag spike that you'll see sometimes where you just teleport somewhere but for the most part, interpolation makes the game a lot less choppy by doing that. So that helps a lot if there is latency between those region servers. Another issue that arises when we have region servers are that it's possible that one area of the region is going to become super popular and one region server is going to get overloaded. What can we actually do then? Well even though up to this point i've kind of been acting like region servers have been their own dedicated servers and every single region should go on one server, that's not the case. These are processes that are running in something like a virtual environment like docker and as a result, we can perform something like consistent hashing on them such that all of the servers get an equal amount of players on them. If you know four regions total for 100 players and then one region also has 100 players because it's being relatively overloaded and you have two servers, you can put those first four regions on one server and the last popular region on the other and that way you can kind of dynamically shard and get a good balance at the end of the day in order to avoid hot spots and then the last and final point that i kind of want to make about all of this is that in order to speed up latency even further and this is especially prevalent for if you're running games in web browsers, you can use something like a CDN in order to pass kind of images that might be sent from a server back to a client like a sprite over and over again and as a result of that, the CDN can just quickly distribute all of these relatively static images over to the client and that's going to reduce latency quite a bit. 
- ![[Screenshot 2024-11-27 at 3.42.19 AM.png]]
	- Diagram
		- Okay and of course as per all of my videos, I will cap things off with a nice whiteboard diagram. As you can see i've got my handy pens back, thank goodness. So let's get into it. Typically we are going to have a client and the first thing that they're going to do is hit a load balancer because they're trying to be loading into a game and so that can hit them with one of the instances of our game match service which is basically just going to find a bunch of other users from similar geographic regions and match them together probably put them all in one region server for a given game ID and you can use consistent hashing such that that server is only being used for you know a few game lobbies and not all of them, and so you know, generally speaking, everyone starts in a plane or something and so I imagine they'll all start in the same region and as they kind of cross regions and disperse, then you can go ahead and dynamically re-partition in a way such that the player base is kind of nice and spread out all over all of your servers. So another thing you may notice is something that i haven't really discussed too much is actually how we're going to be fault tolerant here because up to this point, i've kind of mentioned things are in memory but i haven't really mentioned the persistence of the game which is going to be necessary because these servers can go down. Well if you remember our stock exchange video, basically what we had is this matching engine where all of our state was stored in memory and then what we had was a secondary matching engine which was basically listening to all of the outgoing messages sent by the primary matching engine and basically rebuilding its own state on the secondary matching engine such that it had the same exact state as the primary and that's exactly what we're going to be doing here. So we can have a few standby nodes for every single region that's basically going to be listening to all of the outgoing messages from you know the primary region server and as a result, it's going to build up an identical state such that if the primary is to ever go down, the backup can go ahead and take over and you can have all the primaries and backups occasionally sending heartbeats to something like zookeeper in order to go ahead and deal with that transition. As we know, you know, when players are moving between region one and region two or region two and region three, locking is going to have to occur and in addition, you know, we might have multiple region servers actually communicating with the client at one time. The client is only going to be sending state updates to one region server but it might be listening to many and that's an important distinction to realize and then finally like i mentioned, we have our kind of CDN which is going to be located in a geographic area that's close to our client, it's going to hold static images that they may have to load quickly, and that could be any object in game or you know i don't know music for all i care and yeah that's just going to speed things up even further.
		- All right everybody, I hope that you all enjoyed this video. I know the content in this one's actually pretty tough and I hope that the images that I attach are going to help you all understand but truthfully it took me a while to even get a grasp on this one and there aren't too many systems design videos on actually building MMO video games. It's really not easy, so you know if you made it this far kudos to you.