---
Source:
  - https://www.youtube.com/watch?v=A-GcQwo434w
---
- ![[Screenshot 2024-11-25 at 2.23.29 PM.png]]
	- Introduction
		- So anyways, today we're going to be doing [[TicketMaster]] and i personally am very excited to be doing this video. Mainly only because it's the last "grokking the systems design" problem which means I don't have to deal with this book anymore because it sucks. This problem is no exception. I think they do a pretty poor job covering it and uh, I don't know, I just don't feel like they really think through it that much and I don't really have that much to add because they just don't specify the problem that well in the first place but i'll try and think of a few different options that you could take had there been different functional requirements and we can discuss those a little bit before we ultimately get into a diagram. Anyways let me go ahead and crank this video out because i got a lot to do today and i don't really have too much time to be recording this but uh yeah after this one we're going to start doing some non-grokking problems which is where i hope that this channel can actually add some additional value to you guys because i've more or less just been plagiarizing some other random for the last, I don't know, month or so and i feel bad about it. Alright, let's get into it.  
	- TicketMaster (Functional Requirements)
		- Description
			- City > Movie > Theater > Time > Seats
			- If number of seats are available, reserve them for the user until they are booked
			- If seats reserved but not booked, allow users to enter a FIFO waitlist in case they become free
		- All right so let's talk about some functional requirements for our TicketMaster service. So basically here's going to be the general user workflow that we might expect someone to go through. Basically, they want to go to some sort of movie. Let's just assume movies for now because more or less all the tickets are pretty comparable, right, like there aren't different sub-sections within a movie theater that you know certain parts of it cost more than others but we can talk about that in our discussion section. Um basically let's assume that a user is going to select the city where they want to view a movie, then they're shown a list of movies that are available in that city. Then after that, they can go ahead and choose a theater showing that movie and then finally ultimately a show time for that given theater. Once they basically would be able to do this, they could select the number of seats that they want for that show time and assuming the number of seats are available and not currently in process of being reserved by someone else, they can go ahead and select a few seats on a seat chart and then they will either be able to get those all booked together or none of them booked. If it happens to be the case that some of those seats are not available or there aren't actually enough left, however basically they haven't been fully reserved yet but rather someone else is in the process of booking them and could in theory back out and cancel, they will be added to a wait list where they will basically be waiting around for the person currently booking that number of seats to either reserve them successfully or drop out and if they were to drop out, whoever is next up on the wait list can go ahead and try to reserve them themselves. We can basically go ahead and assume that if someone is in the process of booking seats, after they have basically selected the number of seats they want in a given theater, they'll have say five minutes in order to finalize that booking or else they're going to be removed from that list and basically forfeit the seats that they had reserved and someone else can go ahead and swoop them up that was on the waitlist. 
	- TicketMaster (Capacity Estimates)
		- Description
			- 500 cities, 10 theaters per city,
			- 2000 seats per theater, 2 shows per day
			- 50 bytes per row of booking data
			- 500$*$ 10 $*$ 2000 $*$ 2 $*$ 50 bytes = 1gb/day
		- Alrighty, so what about capacity estimates? In terms of the assumptions and the estimate numbers, I again tend to rip these from "grokking the system's design" and so i've done the same thing here. We're basically going to go ahead and assume there are about 500 cities where each city has about 10 movie theaters and then assuming there are 2,000 seats per theater and about 2 shows per day, we can go ahead and multiply those all together and then basically assume that each booking in our database is going to need about 50 bytes of data. That might include something like an id, a number of seats, a show id, a movie id and then the actual numbers of the seats themselves and their status. Maybe an email or some payment information. So assuming 50 bytes, we basically then say 500 times 10 times 2,000 times 2 times 50 bytes means that we're going to be putting about a gigabyte per day of booking data in our database. So inherently speaking, you know there's definitely technology that has the capacity to hold all of this without having to necessarily use sharding, however just in terms of you know speeding things up or designing for scalability in the future if our platform were to grow, it does make sense to at least talk about sharding and obviously i'll do that in a later part of this video. 
	- TicketMaster (API Design)
		- Description
			- getCities()
			- getMovies(cityId)
			- getTheaters(cityId, movieId)
			- getShowTimes(theaterId)
			- bookSeats(showId, seatIds)
		- Next, let's go over a pretty basic api for our service. Like i mentioned, there's a pretty significant or kind of not complex but a very streamlined user flow that is very step based and as a result we're going to have a lot of get endpoints that are basically, you know fetching certain data based on the criteria that we've already put in. So things like an endpoint to actually get the cities that our service supports, to get the movies given a city, to basically get theaters given the movie and the city, and then to get times given a specific theater, movie, and city that theater is in. And then finally the most important endpoint which is actually going to be to either choose seats, you can call it or basically make a booking. I'm not necessarily going to list out every single parameter for all of these endpoints because that's not as important, but what's more important is to think about how these endpoints pertain to basically the general user flow that we're trying to support, the order that they would be called in, and additionally, the underlying database schema that we're going to have to have in order to support something like this and kind of the one-to-many relationships that we're going to be having in our service, so i'll discuss that in a moment.
	- TicketMaster (Database Schema)
		- Description
			- Cities (id, name)
			- Movies (id, name, cityIds)
			- Theaters(id, name, address, cityId)
			- MovieShow (movieId, TheaterId, time)
			- MovieSeats (id, showId, name, status)
		- Um as i previously mentioned, we're definitely going to have a decently complex database schema here. The reason for that being that we're going to have a lot of these one-to-many relationships. So don't really worry about the fields themselves too much here but just to give you a sense of some of the tables that we might have, besides basic things like users, basically, we know we have a table representing cities and within each city, a city can have many movies. In addition to movies, they're going to be a bunch of theaters where a city can have many theaters and then in combination for a movie and theater, you can have a movie show and that's going to have something like a time and then each movie show is going to basically have a one-to-many relationship with movie seats which can be booked. There's going to be a given user that has them booked or they can be available as well and we definitely want these to be basically materialized as in, you know, you don't want to be adding these rows when they're getting booked but it would be good if every single seat the second movie show was created was pre-populated in the database. The reason for this being that we can do something called materializing conflicts which means that we're sure that basically all locking is going to work on these rows so that we don't have any concurrency bugs but i'll touch upon that more later. So basically we've spoken about our initial database schema and then kind of the last element of this is obviously going to be the booking because the booking is going to be the most complex part by virtue of having this concept of a waitlist that we have to deal with and also the possibility that a booking can either be confirmed or cancelled down the line and we have to keep track of all those basically unconfirmed and uncanceled bookings which are basically in purgatory to see what we can do if you know one of them that's ahead in that queue is going to cancel. So, we'll talk about that in just a moment.
- ![[Screenshot 2024-11-25 at 2.48.38 PM.png]]
	- TicketMaster (Architectural Overview)
		- All right, so now that we've kind of laid out the background for this problem, let's talk about some considerations that we have to think about and some of the design choices that we're going to make for how we can properly implement TicketMaster. So the first thing is that if you guys haven't thought about it yet, I already kind of hinted at this but i basically said it's very important that when a user chooses a certain number of seats, it is important that they make sure to book all of those seats and it's important that if they don't book all of those seats, they're not getting a partial amount, they're getting none. That should imply atomicity to you. What that means is that we want a database supporting acid transactions in the sense that basically either all of these writes go through or none of them do. Additionally what acidity is going to help us do here is make sure that we don't have any issues with concurrency. Imagine that two users both try and book the same three seats at once and you know it's me and my friend and i get one of the three seats and he gets the other two. That wouldn't be good. We want to make sure that basically somebody outright wins and somebody outright loses and that is kind of defined by serializability. There's no interleaving of those three operations. Either they all go through together and they all either happen before or after someone else's operation. So as a result of that, it's very important that we use a database that supports acid properties and generally that's going to be a relational database like MySQL or Postgres. So we'll discuss about how we can go ahead and shard and replicate that data in a little bit, but that's a very important thing to note because using something like a NoSQL database here that doesn't support transactions would give us a huge risk of dealing with all of these issues with concurrency where we have all of these partial bookings and then nobody ends up happy. Okay, additionally another thing i want to basically go into a little bit is kind of some of the functional requirements themselves because they're a little ambiguous. So i've mentioned that what really happens in at least this problem is that the user basically says i want you know three seats, i want four seats, and then our service is going to say okay well there are three seats left so you can go ahead and try and book those, or you know there are three seats left but someone else is trying to currently book those so go on the waiting list. Well in reality, people don't really book that way. The way they book is you know they want a certain few seats and then i would imagine that the service would basically say well these are either available or they aren't or you know maybe someone else is trying to book them but if that doesn't work out, you can book them yourself. The issue there is then what would need to happen is for every single seat, we would need to basically keep a list of all the users waiting for it and keep track of who's waiting for every single seat and this gets really complicated because what it implies is that you know i could be waiting for seats four, five, and six and then i have user one currently booking seat 4, user two currently booking seat 5 and user three currently booking for seat 6 and what might end up happening is that now i'm waiting on three people in order to basically get my own booking working and say you know user one drops out so now i can get c4 but now i'm you know still waiting some unclear amount of time for seats five and six in order to kind of figure that all out. So i don't know. I'm not exactly sure what TicketMaster actually does in terms of this whole waiting list queuing thing but i guess if we wanted to do kind of seat level waiting list, that would be very complicated. Maybe what would be a little bit more practical is you know for things like sports scams where there are a lot of different prices of tickets and you know basically if i'm sitting in the upper deck, it's going to be a lot less expensive than if i was sitting on like the field level. Perhaps what you would do is you would split the stadium into sections and then you would act like each each section is its own show, right? Where you know all of basically the waiting is for a given section as opposed to the entire event as a whole. So i guess that would be kind of a clever solution, but then you know you're limiting users to only being able to book within one section at a time which shouldn't be a huge deal because generally speaking if you're buying tickets, you want to be sitting next to, you know, the people you're booking with. So i just wanted to consider that but you know that kind of opens the floor for how we're actually going to solve this problem. So basically like i said, for every single potential booking and that means one where either you have seats reserved or you don't and you're waiting for them, we have to keep track of that. And the reasoning for this is let's say i'm waiting on seats that someone else currently has reserved but they might drop out, it might be the case that other people are also waiting on those same seats and we've basically said we want to do whoever kind of becomes the next person to get access to trying to book those seats in a fair way. 
		- (1) Which means we need to implement a queue or a linked list of sorts where we're keeping track of who basically said, I want these seats first and as a result when they come available, it's the person who came in first that is going to get the first access to trying to book them again. So how can we actually do this? Well, we've already mentioned that we have this relational database of all of our seats but in addition to that, we should probably have a relational table called bookings. So every single time that someone requests seats whether they're actively trying to reserve them and have them reserved but haven't finished the payment yet or they're in this kind of waiting list for them, they should be assigned some sort of booking ID and what we can do with this booking id, is we can put all of these booking ids somewhere in memory and maintain a data structure that's going to help us keep track of them such that we can perform the handover if someone were to kind of back out of trying to perform a booking or we can basically remove them from the waiting pool if another booking was successful and now their booking becomes invalid. So let's talk about two different types of memory structures that we can use in order to maintain basically all of the people who are actively trying to book something, and all of the people who are waiting for seats to become available. So let's assume we're going to basically be using two linked hash lists. So i should kind of basically say that's a linked list where there's also a hash map pointing to each element of the linked list. So why is this useful? Well the hashmap is going to point to each element of the linked list by booking id, and then the linked list itself is just going to order all of the elements inside of it and i'll explain why that's useful in a second. So let's imagine that we have uh you know a movie theater and it has a show for i don't know batman. So batman is going to open up and we have a ton of users and they're all going to try and get seats and now let's say what we have is 10 users are able to basically make seat selections and get those seats reserved. So now they all have five minutes to make their booking. All 10 of those people are going to go in one linked hash list. So we have all of their booking ids in this linked list, and now the following is going to happen. We basically have a process saying, I'm only going to check the head of the linked list but because the linked list is ordered, I know that if the head is expired, I can start checking subsequent elements. You only have to check the first element for being expired because you know that all subsequent elements in the linked list were added on later than the first element. So the linked list makes it really easy to basically check for the expiration of certain elements. Additionally, what the linked list or the hash part of the linked list helps us do is say, okay, let's say one of these users was successfully able to book. They got their payment information in. Those seats are now reserved. So now we're going to make a call to our database using a transaction so we make sure that all the seats they selected are given to them. Once that happens, the seats are given to them, and then the booking is confirmed and we can go remove that booking id from the linked list and we can do so by finding the location of that booking in the linked list using the hashmap component of it. So you basically get the value corresponding to the booking ID and so that way we can really quickly remove that value from the hashmap and update the number of seats left. Once we do that, we can say oh well let's take a look at our waiting linked hash lists. Let's say there used to be 10 seats left but now there are only five seats left. All the people in our waiting hash list who wanted six or more seats, we can iterate through that list and remove them out. Additionally, what would happen if someone from the actively booking linked list were to cancel their reservation. Well once that happened, we would use the hash map again to basically remove that node from the active linked list and then we would pick a node from the head of the waiting linked list to put at the end of our active waiting link list. Again, we're running processes such that we're making sure to basically expire elements of both linked lists as the actual time expiration period passes, but i'll make sure to have this all written out on a whiteboard so that it's easier to visualize for you guys. As for clients on the wait linked list, obviously we don't just want to leave them hanging and never alert them and make them just like constantly refresh their page to see if they can finally make a booking. So what we could do is use some sort of real-time pull technology such as WebSockets or long polling or server-side events. I think long polling or server-side events are probably the better options here just because it's not a bi-directional communication, so maybe something like server-side events would be good where you're just sending basically all the users in the waitlist what position they're currently on and also things like how many seats are left in the show to potentially be booked so they can get a sense of whether things are looking good for them or not. 
		- Another thing to quickly note is that any time we're dealing with memory, there are a lot of you know considerations to think about especially as it pertains to race conditions and concurrency. Um, even though i've mentioned in a past video that i believe Redis is single threaded, if we aren't using redis here and say we're just running a second process on our node holding our database, we have to make sure that we're using locks on our linked list because otherwise we can have concurrency bugs where by using that read modify write cycle to write to the tail of a linked list, you end up not actually writing to the tail node but writing to say the node before the tail node because you read the old tail node and then tried to make your write. So it's very important that you know when dealing with in-memory data structures, if you have multiple threads on say a server that are trying to deal with all these bookings, that you're not having concurrency issues and that you're locking where need be in order to make sure that certain entries of that linked list aren't basically being overwritten. Another consideration to mention is the following: like i mentioned you could use redis as the place where you're holding these two linked lists combined with hashmaps, however it may be a lot easier to just put this as a separate thread or a separate program on your actual database node and here's my reasoning for saying so. If you have this linked list that needs to basically be coordinated with all of the bookings in your database and they're on different nodes, then you need something like a two-phase commit protocol to ensure that they are basically coordinated over the network because otherwise what would happen is a booking might be successful but then you never remove that booking from your active linked list and as a result of that, what's going to happen is no one from the basically the waiting linked list will be notified that there are fewer seats now or that you know they're no longer eligible to actually get those seats and the same applies for if someone were to cancel their booking. No one in the waiting linked list would basically be promoted. So that's why you basically need this two-phase commit if they're on different nodes and have to communicate over the network is because you want them to stay in sync. However two-phase commit is a very slow thing. It requires a lot of network coordination and overhead and as a result of that it would probably be better if these two processes were at least on the same node. Additionally as far as fault tolerance goes, you could definitely replicate both of these linked lists to other nodes or other redis instances or something like that in a single leader replication type of configuration and then furthermore as far as sharding goes it makes a lot of sense naturally speaking to basically shard everything based on the actual show ID itself. So you want to shard in a manner such that all of the linked lists corresponding to one given show or one given event is going to be on the same node. There are ways you could shard otherwise such as you know like the same city or the same movie theater or the same movie itself, but that doesn't really make sense because you want it to be the case that that linked list is on one machine and that makes it easier to get everything expired, coordinate all those bookings together, take advantage of better cash locality, so you know it's important to use some sort of consistent hashing schema to basically shard based on the event ID. And then finally speaking of caching, one thing that you could do to actually speed things up is I mentioned that it's possible that the linked lists and the database containing bookings are going to be on different nodes. However, if that's the case, what you could do is use a sort of write-back cache on the node containing the linked lists such that it's very easy to calculate the number of remaining seats for a given event and that way you don't have to pull from the database every single time and say oh how many seats are left and you know are all of these waiting users still valid or do we have to remove them from the waiting linked list? So something like a write back cache could work well here or it doesn't even necessarily have to be write back, but the point is by caching the number of remaining seats, we can really quickly um figure out who should still be in the waiting list and who should not be. Anyways, I hope that made sense to you guys. I'm now going to draw out a diagram 
	- Diagram
		- This diagram is actually pretty straightforward when you try to figure out what's going on, so let's go through it real quick. As you can see, we have a client i've drawn out the phone this time because i was feeling artistic, which hits a load balancer can be in passive-active or active-active configuration for some redundancy and then first of all, we're going to have our show service. This is useful for all of our get endpoints that i previously mentioned and those can be run through a cache because a lot of these results are just going to be duplicates. It's going to be the case that me and anyone lives near me is going to get a similar result from this, so having a cache in front of this and possibly even a CDN for something like static content or images that correspond to movies or theaters is going to speed things up quite a bit. Obviously that's going to hit all of our MySQL databases which i've covered those earlier in terms of the schemas that we're holding. That's things like the cities table, movies table movie shows table, movie seats table, bookings table, etc etc, and we can just use single leader replication for those because there's going to be relatively infrequent writes and what we really care about is more the consistency of our data and as a result, just having a single place to write to and possibly some sharding is going to make our life easier than using any sort of leaderless replication schema. On the other end of our service, we have our booking service. Now this is where as of now, I've currently got some sort of two-phase commit protocol where every single time we're going to be either canceling or confirming a booking, we have a two-phase commit to our booking queues which are held in Redis and also our either write-back shows cache or a MySQL database, you can choose what type of cache you want. But either way as we know like i mentioned two-phase commit is pretty inefficient and if we really want to be optimizing for speed here, even though TicketMaster probably doesn't need it that much because there's still just like a limited amount of shows that people can you know register for and also a limited amount of seats per show, then what we could do to optimize this is run basically a separate queue process on some other one of our servers. Probably our database servers and that way we wouldn't have to coordinate over the network itself. Finally, once we have all of our information in these queues, we can go ahead and use a real-time protocol such as server sent events to keep all of our clients who are waiting for seats to open up and basically alert them where in the queue they are and that'll get them a sense of whether or not they basically need to cancel, whether or not they're waiting, or they should stay in that queue. Um yeah, so as we know there's going to be some sort of process basically going through the queues and expiring things as we go, and when that happens, again there's going to need to be some sort of two-phase commit protocol where we're also updating our mysql database at the same time. So there's definitely a lot of coordination that needs to happen. The important amount of sharding that needs to be done should really just be sharded by like show id or event id and that way we can keep all elements of the cues in the same Redis instance and similarly all potential bookings for a given show on the same MySQL node and all of basically the seats for a given show on the same MySQL node and that's good so we don't have to do cross-partition transactions when we do transactions to book multiple seats at the same time 
		- All right guys, i hope this video was helpful. Oh we finally made it through the grokking content which is great because i really want to get on to other stuff. I think there are a lot more interesting problems to be doing and it'll cover some more of those original concepts that i did in my first 50 videos on this channel. Anyways as always i want to thank you all for watching. If you made it to this point, you're a true sigma male giga chad legend, and i'll see you in the next one. Give me a comment and let me know what can be improved as always and i'll try and get back to you. Have a good one guys.