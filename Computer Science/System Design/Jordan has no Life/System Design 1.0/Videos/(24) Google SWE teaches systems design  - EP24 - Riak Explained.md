---
Source:
  - https://www.youtube.com/watch?v=5P6omeGwQ8c
---
- ![[Screenshot 2024-10-09 at 3.32.41 AM.png]]
	- Intro
		- hey everyone i am back for yet another video and today's is going to be about Riak. A distributed key value store. If you asked my ex-girlfriend, she would say that me in this video have a lot in common in the sense that the video is not going to be particularly interesting and it certainly is not going to last very long. That being said, it's important that we cover Riak because it seems to have come up a decent amount in my personal studying as a data system that a decent amount of companies will use. So as a result, I'm going to go over it pretty quickly
	- [[Riak]] Background
		- Description
			- Riak is another type of distributed database system that hopes to optimize on great write and read throughput. It has many similarities to Cassandra (such as the replication schema, and the partitioning schema), which I have covered previously, so it seems most reasonable to discuss the main differences between it and Cassandra
		- All righty, so Riak. What is it? Riak is yet another distributed database system that tries to achieve really high read and write throughput. It has a ton of similarities to Cassandra which I've covered in the past. In terms of both the replication, the partitioning, the actual rate engine, and I've covered those all previously so if you haven't watched that video i'd recommend just watching the Cassandra video and then this video will make a lot more sense, but it just mainly seems the most reasonable to discuss kind of the differences between Riak and Cassandra because that's what makes Riak a little bit useful and there are really only two main ones so we'll go ahead and talk about those now  
	- Data Modeling
		- Description
			- Unlike Cassandra which is a wide column store (and has primary and clustering keys for secondary indexes), Riak is just a basic key-value store where the value can be literally anything (allows for more complex things to be stored like images or a deeply nested json string).
			- Generally speaking, to do queries on data for something other than a key requires adding extra pieces of metadata to each key-value pair for a secondary index or integrating with the Riak search index (we will discuss search indexes in the future).
		- Okay so in terms of data modeling like i mentioned in the past, Cassandra is a wide column store which means that you have this concept of a row key, and then you have any amount of column keys attached to that which have values, and you can also have this concept of clustering keys which within a partition and partitions are kind of delineated by that range of row key, the clustering keys help determine the sort order. On the other hand, Riak is really just a key value store which means that all you really have is key and some value where the value can basically be anything that means it could be a blob which is kind of like a file. It could be JSON. It could just be a string or a number or anything along those lines. So it means that in theory, you could probably store something a little bit more complex like you know a huge JSON document with you know tons of lists in that or even nested things or an image but at the same time, it means that you're probably not really going to have great secondary index capabilities and querying based off things in the actual value itself. You can do this using something called the secondary index in Riak but generally it seems not very efficient because every single key value pair will have to have this extra metadata now that enables you to search by the secondary index. You can also integrate your Riak keys and values with um a Riak search index which is something I'll discuss in the future but um for now, the point is that natively Riak key value, um you know it's mainly just if you want to be able to search on keys  
	- Conflict Resolution
		- Description
			- Both Riak and Cassandra use a leaderless replication system, which inevitably will lead to conflicting concurrent writes.
			- Recall: Cassandra uses last write wins, which loses data and is based on unreliable timestamps.
			- Instead, Riak keeps dotted version vectors associated with all objects in a database allowing it to detect concurrent writes and store them all as siblings. The next application server that reads this field is supposed to take all of the siblings into consideration and merge them in a reasonable way for the next write.
		- Okay what about conflict resolution because this is the other kind of important area. So if you recall both Riak and Cassandra are using a dynamo-style implementation which means that all writes are not going to one leader node but rather they can pretty much go to any single node in the cluster that's going to be handling that partition and that node can accept that write. So inevitably what's going to happen is there will be race conditions and there will be write conflicts. As for how Cassandra deals with this, they use last write wins. So basically each write once it reaches the server is assigned a timestamp and the write ultimately with the higher timestamp is the one that's kept. There are two issues with this. The first is that timestamps are unreliable so those servers might be out of sync and so the wrong write may win and then the second one is that what happens with the write that basically came in a millisecond before, well it's just lost. No one even hears of it. No one knows why it's lost. It's just gone. So how does Riak go and try and fix this. Well they use something called version vectors. Version vectors are a topic that i touched upon way back earlier on the channel in the multi-leader replication video but the point is version vectors are just a good way of keeping track of kind of what a client uh has known about was in the database whenever they made a write and by doing so, you can kind of keep track of the dependencies of a write and see if two rights for the same object were causally related as in one was done knowing about the other or if they were concurrent, one was done without knowing about the other and if they're concurrent what you go ahead and do is actually store them as siblings and once two writes are stored as siblings, it means that anyone reading from the database in the future will receive both of those siblings as a read and go ahead and try to merge them in the application code. So in our back end for example, we would be writing extra code to handle the fact that there may be siblings on a read and then we would merge those in one way or another as we see fit and put them back in the database but what if for example you don't actually want to deal with the merging and say you just want something that works pretty seamlessly like a counter or a set or a map well?
	- CRDTs
		- Description
			- If you don't want to potentially take upon the burden of having to merge database siblings, Riak has good support for CRDTs for structures like:
				- Counters
				- Sets
				- Maps
		- Fortunately we talked about that in the last video and that's called a CRDT. A conflict-free replicated data type which is just any sort of data structure that you can kind of have multiple sources of writes for and eventually they will converge to the same state. So some examples of this that Riak has are counters, sets, and maps and as a result if we don't want to be writing custom application code in order to kind of handle the fact that there may be siblings in the database, using something like a CRDT allows us to have the database kind of handle those discrepancies itself and deal with the conflicts automatically which is super useful. 
- ![[Screenshot 2024-10-09 at 3.33.09 AM.png]]
	- Conclusion
		- Description
			- Riak is yet another high throughput database which achieves its goals through partitioning, multi-master replication, LSM trees, and read repair + anti-entropy. 
			- Unlike Cassandra, it is a key value store, which means that generally you should only use it if single key accesses are important, as opposed to range queries over a single partition (secondary indexes in Riak are not ideal).
			- Compared to Cassandra, the main benefits of using Riak are greater flexibility in what can be stored as values, as well as no data loss on conflicting writes, either via the use of application code for merging siblings or CRDTs.
		- Okay so in conclusion Riak is another super high throughput database. However it only is really high throughput for single key reads and writes. Things like range scans over a certain you know primary key but a given clustering key as would work in Cassandra don't really work that way. That being said, if you actually look at the internals of Riak and Cassandra, they look super similar. They're both dealing with the same type of partitioning schema via consistent hashing on a key, the same type of multi-master replication, LSM trees and read repair and entropy. So that's how they're able to achieve that high write throughput but unlike Cassandra like i said Riak gives you a little bit more flexibility in terms of how you store your data simply because the value can literally be anything but it comes at the cost of the fact that since it's only a key value store doing things like sorting within a partition are not very easy and it requires you to either add extra metadata for a secondary index or integrate some extra search index technology to work with your data and then compared to Cassandra kind of the main benefits of using Riak are like i said greater flexibility in data storage due to values and additionally the fact that if you have conflicting writes, we're no longer using last write wins which is kind of one of the biggest pitfalls of Cassandra. It's kind of like the easy way out for dealing with right conflicts and instead what Riak will allow you to do is basically deal with siblings in a database and merge those in any way you see fit or if you don't want to do that, merge them automatically in the databases themselves using CRDTs. Okay guys i hope this video was helpful, like i said it was going to be a pretty short one but the good thing is that now that we've touched on this key value store we can start talking about in-memory key value stores and dealing with caching