---
Source:
  - https://www.youtube.com/watch?v=2APFrmoqxKc
---
- ![[Screenshot 2024-11-15 at 1.35.11 AM.png]]
	- Introduction     
	    - There's really not too much left for me to talk about, you know. I can start talking about some really complicated distributed systems topics but, you know, at the end of the day, even though I like talking about that stuff, this is more of a systems design prep channel more so than just a super you know theoretical distributed systems channel and so i'm probably going to post um you know today's video and then maybe one more and i think that'll probably uh you know kind of round out the series for distributed systems concepts and from there we can start doing actual interview questions which i hope to start in early June. So hopefully that gives you a sense of kind of where the channel is at, but without further ado, let's talk about some graph databases.
	- [[Neo4j]] (Background) 
	    - Description
		    - Sometimes, certain data is best represented by a graph - this includes things like social relationships (Facebook friends), map data, or even the results of web crawler links. As a result, certain graph databases have been developed. One of the most popular is Neo4j, which has a very unique architecture.
		- Okay Neo4j. what is it? Well basically a ton of data these days is best represented in a graphical format. That might be something like facebook friend relationships, map data on google maps, or even something like the page rank algorithm and web crawler links. So basically a bunch of databases have kind of popped up to better process this data where you're not necessarily going and scanning a bunch of rows in a table to kind of fit some nodes that match a bunch of properties, but rather you're trying to find all of these nodes that have really complex relationships within the data and deeply nested data that you know you have to be able to deeply query through some sort of breadth or depth first search in order to gain insights on it. So the graph database that we're going to be talking about today is Neo4j because they've kind of been spearheading the graph database, you know kind of movement and they have a very unique architecture.
	- Data Format
		- Description
			- Nodes: Point in the graph
			- Properties: Key value pairs on nodes, do not need to follow a particular structure
			- Relationships: Directed edges on nodes
			- Labels: Information corresponding to edges, can also be queried on
		- So, generally speaking, looking at the data format in a graph, we have a bunch of different types of nodes. Nodes can hold properties which don't have to necessarily follow any certain format, it's kind of like NoSQL in that sense. We are, you know, free in our schema and then a bunch of relationships which is kind of the bread and butter of the graphs in the sense that relationships are directed edges on the nodes which themselves can have labels which act as a useful property in querying.
	- Native vs. Non Native Graph Databases
		- Description
			- Unlike certain graph databases, which are essentially a graph query language used as an abstraction on top of an existing distributed database, Neo4j is actually known as a native graph database
			- By representing data in its actual graph form on disk, Neo4j is able to have significant performance improvements when dealing with the data. 
		- Okay, in terms of native and non-native graph databases, well basically a good subset of graph databases are known as something that aren't non-native, which means that they're basically abstractions built upon existing data stores, like i don't know, Cassandra or perhaps even a relational database system and what those do, are they basically give you a graph querying language, but at the end of the day, the data is stored in the same way that you know i've kind of discussed on this channel so far. You know in a typical type of indexing system. However, on the contrary, Neo4j is what's known as a native graph database in the sense that it stores the data on disk in this different format which i'm going to explain in the subsequent slides and by doing so, it is much better able to support graph queries and achieve higher throughput.
	- Data Storage
		- Description
			- Nodes, relationships, labels, and properties all kept in different files. Want to optimize for storing similar relationships close to one another on disk for fast traversals
			- Each node contains a pointer to its first relationships (which contains pointers to the next relationship form that node), effectively acting as a mini index for them. In this way, the data is stored as tons of linked lists on disk.
			- This is known as index-free adjacency
		- So, basically, nodes, relationships, labels, and properties are all going to be stored in different sets of files and all of these files are effectively just going to be linked lists. So what type of data are we storing in these linked lists? Well, the linked lists are going to give us the disk address from you know say one node to its corresponding relationships or one relationship to the next relationship on the same starting node and by doing this, we can quickly run all of these queries because as opposed to, you know, a traditional database where you basically have to go ahead and hit an index every single time you want to find all of the you know related nodes or anything like that, by using this linked list, we're basically just running a disk traversal and using all of these disk pointers with hopefully relatively adjacent data in order to get very fast performance. So for example, each node has a pointer to its first relationship and then the first relationship has a pointer to the second relationship from that starting node, and then onwards and onwards and onwards. This is what's known as index free adjacency and index free adjacency is why Neo4j is able to achieve very fast performance.
- ![[Screenshot 2024-11-15 at 1.46.44 AM.png]]
	- Avoiding Indexes
		- Description
			- Recall: If all nodes are being added to an index, finding a node in an index scales logarithmically with the size of the dataset. Hence, every single graph query will take longer if using a huge graph.
			- By using index-free adjacency, we can ensure that the speed of a query depends only on the number of nodes involved in it, as opposed to the size of the whole graph.
			- Non native graph solutions have to use many indexes to link nodes together with relationships and as a result, they become slow
		- So, why is it so important that we aren't using an index here? Well, basically, if all nodes are being added to an index, what this means is that finding a node in an index is going to scale logarithmically with that. So for huge graphs, we have to basically run a binary search every single time on the index and if we're running all of these binary searches, that is log(n) with respect to the number of nodes in a graph and as a result, even if the query itself that we're making is relatively small, by virtue of having to go through this index every single time, we are incurring a huge performance hit. On the other hand, by not having to use an index for our graph database and Neo4j specifically, we can basically ensure that the actual time it takes to run a given query is directly proportional to the number of nodes that are actually being touched in that graph query. Like i said, an index here is basically just going to be adding an extra step to a graph query. It's like having to hit a phone book every single time that you want to go from one node to the other because you have to find where on disk that second node is and as a result of that, huge graphs are going to have to you know, you have to go through that phone book every single time. It's going to take forever, and so it's really important to actually be able to avoid indexes 
	- Challenges with Graph Data
		- Description
			- We need ACID properties:
				- Modifying a relationship is not an isolated operation - it also often requires modifying the nodes on both ends of a relationship. As a result, Neo4j has been forced to use a write ahead log for atomicity, as well as locking in order to ensure that two transactions do not get jumbled up, leading to an inconsistent graph.
				- This becomes even more problematic on a distributed scale, where potentially multiple nodes in the graph that are being modified are on different partitions in a cluster.
		- So, what are some challenges with actually having to use graph data? Well, for starters, the fact that we're no longer storing things in an index means that we have all of these you know different files where they're referencing one another and as a result, it's really important that we can actually run transactions and have all these acid properties. The reason for this being, we can easily get an inconsistent graph if say, you know, we were to change one edge of the graph and then didn't change the corresponding nodes on each side of the edge and having an inconsistent graph would be hugely impactful and very bad for you know the correctness of our data, that would be, you know, extremely problematic. So Neo4j basically does acid properties in a pretty typical fashion with isolation being implemented via two-phase locking and then atomicity being done using a write ahead log. This also even becomes more of a challenge on a distributed scale because imagine I have two nodes on different partitions in a cluster and then i have to go ahead and change the edge between them and now i have to change two nodes, and we've run into a two-phase commit problem. 
	- Distributed Transaction Ordering
		- Description
			- If a two transactions simultaneously overlap on multiple partitions, all involved partitions need to order them the same way (and so do their replicas!)
			- To do this, Neo4j in a distributed setting uses a very clever method of figuring out which partitions (if any) multiple transactions overlap on, and use on of them as a sort of transaction coordinator in order to ensure that all involved partitions commit at the same time. This way, not all transactions need to do this expensive ordering operation, but only overlapping ones.
			- For replication, Neo4j uses Raft to ensure graph consistency
		- So, like i said, if we have basically a bunch of isolated transactions and they're touching same partitions, we have to be able to make sure that all the partitions agree on the ordering of those transactions. And so obviously this requires something like two-phase commit again but as a kind of cool optimization to two-phase commit, what Neo4j actually does is it will only use two-phase commit on you know two different transactions if it's the case that they overlap in some partition. So this allows them to make sure that they're not having all of this coordination overhead every single time we have some sort of distributed transaction and by avoiding all that coordination overhead in kind of the general majority of cases and only having to do it in the minority of cases, they're able to keep relatively high throughput even when distributing a graph over a large scale. And then additionally just for replication, Neo4j uses raft 
	- Conclusion
		- Description
			- Graph databases have become immensely popular as of recent, because there is tons of deeply relational data where scanning the points themselves is an afterthought. As a result, using something like a native graph database can avoid using a centralized index on every single traversal iteration, and therefore greatly speed up the process of gaining insights
		- Okay, so in conclusion, graph databases are super popular recently because there is so much data that can be represented as a graph and basically the only big limitation up to this point has been the way that we've modeled our data in the past. It's really not efficient to use something like a relational database management system to do a multi-layer graph query. Sure, joins for like a one-layer graph query are fine, but the second you really want to do all sorts of deep traversals, it really doesn't make sense anymore, and as a result, graph databases are growing super quickly and they've allowed us to gain tons of insight into our data and do all sorts of complicated queries. Um, obviously being able to kind of remove the index which seemed like such a fundamental kind of structure to all databases, it almost seems controversial at first but when you really think about it, it makes a lot of sense in the graph use case. So i think it's kind of cool to see how these graph databases work and i hope this video was useful. I think i'm going to have probably one more in this systems design concept series and then we can start getting to practice problems. Have a good one guys.