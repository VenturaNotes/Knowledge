---
Source:
  - https://www.youtube.com/watch?v=W2PlBX81XyA
---
- ![[Screenshot 2024-11-14 at 8.25.04 PM.png]]
	- [[Certificate Transparency]] (Background)
		- Description
			- In the previous video, I mentioned some network protocols that we can use to send byte streams over the internet in a reliable manner. However, how do we ensure that the byte streams are going to the right place? This is where certificate transparency comes in.
			- Certificate transparency is used in HTTPS, which takes traditional HTTP requests and adds an additional security layer (known as SSL/TLS).
		- Okay so [[certificate transparency]]. What is that? Well basically in the past i've talked about TCP and UDP which are both network protocols to ensure that you know bytes kind of get delivered over the internet. However, they don't really ensure that you know they're encrypted in any sort of way or that if they were to get into the wrong hands, that the person wouldn't be able to read them. So instead what we're going to talk about in this video is something called certificate transparency which is used in a separate protocol called HTTPS which is basically built on top of HTTP and uses a SSL or TLS layer of security in order to ensure that bytes sent to you know the party that shouldn't be having them can't go ahead and just interpret them. So how does this work?
	- Man in the Middle Attacks
		- Description
			- Third party reads and intercepts HTTP packets, can see any of the information being sent.
			- Only way to prevent data from being stolen is by encrypting it such that only the server can understand it!
		- Well, just to firstly describe the actual problem that we're trying to fix, we have man in the middle attacks. So man the middle attacks are basically when you have your user and your typical web server and the user thinks they're actually going and sending requests to the web server but somehow the perpetrator is basically disguised their IP in a way such that the user is actually communicating with them and so if they're sending things like passwords or valuable information like location data, the man in the middle can go ahead and just read that. And so the only way to kind of avoid this happening is not necessarily not dealing with man in the middle but just you know being able to actually encrypt your data such that if some malicious third party were to actually get it, they wouldn't be able to understand it. 
	- RSA (Public Key) Encryption
		- Description
			- Parts
				- Server generates a public key and a private key
				- It broadcasts the public key over the network to the client
				- Client encodes any messages it wants to send over he network using the public key
				- The server keeps the private key to itself, as the private key is the only way to decrypt the message
			- Client has to make sure they are using the public key from the server, and not from a man in the middle!!
		- Okay, so in order to do this, we actually use RSA encryption, so this is also known as public key encryption. Basically, any server that you want to communicate with has something called a public key and a private key and that public key, it doesn't really matter who has it, but the point is, you can use this public key to go ahead and encrypt whatever data you want and then go ahead and send that data over the network and only the person with the private key can go ahead and decrypt it to actually read it. So this is actually where you know the server would use their private key and they're the only one that has it because they haven't conveyed that over the network and that way even if the data were to fall into the wrong hands, it would be encrypted which is great. That being said, it comes at the caveat that the client has to make sure they're using the right public key. They want to be sure that they're using it from the server and not necessarily from the actual man in the middle and get tricked. So how can they ensure that they're going ahead and using the right encryption? Well, the server issues something called a certificate. 
	- [[Certificate]]
		- Description
			- Used to verify that a server is actually who it says it is.
			- Each server must register with a Certificate Authority, and the certificate provides information about the server such as its owner, its IP address, its public key, and the authority that it registered with (verifiable via a digital signature).
		- So basically, a certificate goes ahead and says that the server is who they say they are and the certificate gets registered with some centralized certificate authority and the certificate provides things like the owner of the server, its ip address, it's public key because you're going to use that public key to encrypt things, and also this concept of a digital signature which is what the browser is ultimately going to use to determine that the certificate is valid. So how can you go ahead and use that digital signature? 
- ![[Screenshot 2024-11-14 at 8.34.39 PM.png]]
	- [[TLS Handshake]]
		- Description
			- When a browser connects to a server, the server sends its certificate which the browser can verify via the digital signature. Upon completion, it will send some randomly generated encrypted data (using the server public key) to the server, which proves that it has the private key by sending it back properly decrypted.
		- Well, basically you do the following. The browser connects to the server, the server goes ahead and sends that certificate which i just mentioned in the last slide, then the browser is going to verify it via the digital signature which i'll describe in a second and then upon completion, all the server is going to do is basically say, here's a random key, um i'm going to encrypt it using the server's public key and if the server can go ahead and respond using its private key, you know because it was able to successfully decrypt the data, then i know that you are actually the proper server. However, that being said, all of this doesn't necessarily prove that the certificate itself is not bogus. It just proves that once you have a certificate, the server can quickly verify that it is actually the one who you know the certificate corresponds to. 
	- [[Certificate Authority]]
		- Description
			- CA also has a public and private key pair, and uses the private key to encrypt the certificate, which it uses as the digital signature (anyone with the public key can then decrypt the signature).
			- Browsers contain public keys of trusted certificate authorities, and use them to decrypt the message and check if it matches the certificate. Hence we are certain that one of the "trusted" CAs issued it
		- Um, basically that digital signature that i mentioned prior which is issued by a certificate authority, can be verified because the certificate authority also has its own public and private key pair, and in this case, it's going to use its local private key to encrypt the certificate, send out its public key and you know the browser basically has a list of public keys for trusted certificate authorities, and then that way, the browser can go ahead and just decrypt that um you know certificate using that digital signature and if the decryption matches the actual certificate itself, then you know you're good to go and that it is a valid certificate from that certificate authority. However like i said there are a few issues here mainly being that how can we trust the certificate authority. What if the certificate authority was actually to get hacked?
	- Can we trust Certificate Authorities?
		- Description
			- What if a CA got hacked? Then a malicious actor could start giving themselves certificates for domain names that they don't own
			- What we need is certificate transparency
		- So, like i said, the malicious actor could start just issuing itself certificates and basically say, oh i'm netflix.com, you know you can communicate with me. Give me your credit card information, give me your passwords etc etc etc so you know even though you might be able to verify that hey this certificate here is from a certificate authority that i trust um and hey you know now once i have this certificate, i can actually go ahead and send encrypted information back and forth with the server, if you can't trust the CA, what you need is an additional step called certificate transparency. 
	- [[Certificate Transparency]]
		- Description
			- A way of publicly broadcasting all issued certificates so that bogus certificates can be quickly noticed and thrown out.
				- Certificate Logs
				- Monitors
				- Auditors
		- Certificate transparency basically does the following. It goes ahead and publicly broadcasts all issued certificates by every single certificate authority so that bogus certificates can basically be flushed out and it can't be done instantly but you can basically you know have a process where you can relatively quickly notice these bogus certificates and you know revoke them. So this has basically three main components: certificate logs, monitors and, auditors and I'm going to go into all three of those now. 
- ![[Screenshot 2024-11-14 at 8.49.02 PM.png]]
	- Certificate Logs
		- Description
			- Certificate authorities add all certificates to append only logs, which can be queried by a web browser auditor to ensure that a certificate is in it.
			- Each website can then run its own set of programs, known as monitors, which poll the logs for bogus certificates and will report them to be revoked if they find any.
			- However, even this is not perfect:
				- Log shows auditor an entry and then entry is deleted before monitor catches it
				- Log server shows browser and auditor different logs (forks of same log, holding two versions)
		- So basically, certificate authorities can add all the certificates to append only logs and then each of those can be queried by an auditor which is just a program running on the web browser to ensure that a certificate is in it and we'll go ahead and talk about how that works in a second. And then additionally each website so basically each um you know if i'm Netflix and i have my application servers, in addition to running these servers, i'm running a set of programs also known as monitors which are going to basically be pulling from all of these certificate logs and making sure that no one is issuing bogus certificates under my name. If they are, I would go ahead and revoke them. However, this isn't perfect because again how can we make sure that we can actually trust the log. The log could perhaps temporarily show a browser a, bogus entry, and then delete it from the log. If we can't trust you know the server maintaining the log or additionally the log can actually have basically a fork and you can think of this like a git fork where you have two different paths of the log and one path is being shown to the browser and the other path is being shown to the auditor. So the auditor never sees the bad path being shown to the browser and revokes that bad certificate and the browser thinks it's you know dealing with totally fine certificate log thus sending all of this sensitive data and boom now someone else is stealing it. So you know, how can we actually go ahead and make sure that's not happening?
	- Certificate Logs Continued
		- Description
			- How can we detect whether an element is actually in the log and that the log server isn't lying? Merkle Trees!!
				- Generate a Merkle Tree from the log, and get the root hash
				- To ensure a given sequence of elements is the Merkle Tree, basically recreate it on the browser using said sequence of elements, and see if the root hashes match
					- Can be optimized such that you don't need to have every element in the log, only log(n) elements of the log (basically you just need the hashes from every one of the opposite branches)
			- This is really hard to be faked because it would require some other combination of elements that perfectly hashes to the root node
		- Well, this is actually really cool. We're going to be using merkle trees and doing cryptographic proofs. So basically, we're going to first generate a merkle tree from the log itself and get the root hash of it, and then so basically to ensure that a given element is in the merkle tree because you know like i said, the browser's job is to basically say oh is this element here in the actual log itself and you want to be able to trust that. Basically, what you would do is you would go ahead and use that element and go ahead and basically use a bunch of other elements within the merkle tree to basically see if you can recreate that root hash and if you can, you've cryptographically proved that that element is actually in the log itself and i'll demonstrate this process on the next slide so it makes a little bit more sense and it's really hard to fake this because you know faking it insinuates that you are able to find some combination of elements that perfectly hashes to the root that basically involves your fake certificate which is really hard to do. So people basically just assume that this cryptographic proof is pretty solid and set in stone, so i'll show what i mean now.
	- Merkle Tree Proof Visualized
		- Description
			- (1) Is C1 in the log?
			- (2) Gather all the hashes from opposite branches.
			- (3) If H(H(H(C1) + `45ty`) + 99j7) = `tyg4`, we know that it is!
			- (4) But how can we be sure that we even received a correct root hash in the first place? Fork attack! Log shows monitors and browser different versions of the log
		- So imagine we have these four certificates and they're in a merkle tree and feel free to go back to my merkle tree video if you kind of forget what these are but basically it's just a tree of hashes and each higher parent node is a hash of the two children nodes so we have c1, c2, c3, c4. What if we want to ensure that c1 is actually in the tree? So, what we would go ahead and do is basically say okay, we have c1 and then you know in order to go ahead and optimize this proof and not have to reconstruct the entire merkle tree, what you do is you only gather all the hashes from opposite branches, so in this case that would be `45ty` and `99j7` so that way we only have log(n) hashes. This greatly increases the time it takes to do this proof and what we would then basically do is reconstruct the merkle tree root from those hashes and that way we can check if you know if the roots are equal, then we're good to go. So basically, we're saying, we take c1 um you know concatenate it with `45ty` which is the opposite branch, take the hash of that which should be `143c`, concatenate that with `99j7`, take the hash of that and if it's equal to `tyg4`, then we know that c1 is in fact in the lock. However, how can we even be sure that we received a correct root hash in the first place? Um, you know it might be the case that um you know the certificate log server couldn't be trusted and the log again might be able to show um two forks because it might show the browser one and then the monitor a different version. So again we have a potential problem here.
			- #question Did he mean log(n) hashes greatly decreases time to do proof?
	- Fork Consistency
		- Description
			- In order to make sure that it is not being shown a bogus fork of the log, the browser will exchange merkle tree roots with monitors to see if they differ. However, if one log has a few more entires than another, and hasn't been forked, they will have different Merkle roots.
			- You can use Merkle Trees (similarly to how we did before) to prove that one Merkle Tree is a prefix of the other, by showing how the root of the earlier one can be combined with the hashes of new elements in the second tree to output the root of the second tree.
			- Hence, a browser can be sure it is always reading from the same fork, and if it is bad, it will eventually be caught by the gossip pool
		- Well again, we're still using merkle trees to make our proof. So basically, the way the only way to really get around this and this is unfortunately only something that you know kind of has this eventual consistency aspect to it where it's possible the browser can get tricked for a little bit and then it'll eventually realize that it's being tricked is that basically we have this gossip pool and this gossip pool is a bunch of browsers and a bunch of monitors throwing into one centralized area, basically all of these root hashes that they've seen from um from all of the logs that they've been reading and so as a result of that, you know, if a browser throws in some sort of hash and a monitor throws in its own hash of basically the two logs that i've seen, you can actually use merkle trees and do a similar proof to how we did before to show that one log is not actually either the same or a prefix of the other and if we know that one log is not a prefix of the other from the same log server, then clearly that log server is forked and it is a bad actor. Um additionally, browsers will always make sure to read from the same fork so that you know the log server can't just like pull a fast one on them and go ahead and switch it to another fork and then the browser is like wait a second, did i just give up sensitive data? So as long as the browser is reading from the same fork, which it can continue to do by using Merkle trees and kind of checking these uh this like prefix consistency, then the browser will eventually realize due to this gossip pool that it was reading from a bad fork and ultimately that will solve the problem. 
- ![[Screenshot 2024-11-14 at 9.03.31 PM.png]]
	- Certificate Transparency is not Perfect
		- Description
			- While all of the above cryptographic proofs are useful for pointing out a bad actor, the truth of the matter is that they can't do so instantly, and as a result it is still possible for a malicious certificate authority to get away with stealing passwords for at least some small period of time until a monitor catches it.
		- So even though these proofs are really useful for pointing out when a browser has been duped, obviously they're not perfect because it doesn't prevent you know a bad log from basically you know stealing information from a browser for a little bit of time. That being said, the kind of ideal thing is that all of these monitors are running so frequently that they can be caught relatively quickly and as a result, either not too much data will be leaked or you know nothing important will. So it's kind of important to note that certificate transparency isn't perfect but it is a very interesting system that generally speaking kind of just shows off the general approach that a lot of people have taken to kind of building these decentralized networks. 
	- Conclusion
		- Description
			- Certificate Transparency is our first introduction to dealing with decentralized distributed systems where we cannot trust the actors. We will see these types of cryptographic proofs come up over and over again, especially when we cover Bitcoin in the near future!
		- In a subsequent video which i look forward to making where we talk about you know cryptocurrency and blockchain which kind of also relies on this for consistency and the concept of using merkle trees, um we're going to see that basically this concept is something that repeats a lot.