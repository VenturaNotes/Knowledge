---
Source:
  - https://www.youtube.com/watch?v=hUHw4OnPGCA
---
- ![[Screenshot 2024-11-14 at 9.42.47 PM.png]]
	- Bitcoin Design (Background)
		- Description
			- Originally, the motivation behind Bitcoin was to act as a decentralized currency, to eliminate the need for all transactions to be approved and monitored by a third part. However, with a decentralized currency comes potentially many malicious actors that may want to trick others into believing that they have more money than they really do. Bitcoin leverages the use of its blockchain, along with cryptographic proofs to ensure that this does not happen
		- Okay, [[bitcoin]]. What is it? Basically, bitcoin is a decentralized currency that is basically built around blockchain technology, and as a result of not being able to trust all of the parties that are going to be running kind of the the bitcoin blockchain on their local computers, we have to make a bunch of adjustments to you know a typical ordered log algorithm that we might see in something like uh distributed consensus like raft or paxos in order to kind of make this all work out. So let's go ahead and quickly talk about some of the features that bitcoin supports. How blockchain works and basically how that is going to allow us to kind of make payments in an environment where not everyone trusts one another.
	- Coins
		- Description
			- Coins are comprised of a chain of transaction records of every transfer of the coin. The latest record in the chain shows the public key of the current owner
			- Someone can use Jordan's public key to ensure that he was the one who signed the block (with his private key), because when decrypted, the message should be the same as the hash of the previous block!
		- Okay, so what are coins? Coins are basically just a chain of transaction records, and they don't all have to necessarily be stored next to one another in the actual blockchain itself but they do have to basically create this chain of records that shows who basically holds a coin at a given time. So imagine i have some coin, and this is going to be indicated by the fact that um you know as you can see in this first transaction record here, my public key is at the top of it. I have the hash of the previous block that basically gave me that coin, and then i have the previous owner's signature which is basically using the private key to go ahead and encode the hash of the previous block. So then imagine i do a typical purchase that you know, I might end up doing, and i give that coin to an only fans girl. Basically, what i'm now going to do is um, there's going to be a second transaction record that i personally am going to create and what's going to happen is now there's this hash of the previous block where the previous block is referencing when i actually got the coin, and i am going to create a signature where i use my private key and i've discussed private and public keys in a previous video on this channel. I use my private key to go ahead and encrypt basically the hash of the previous block and that way if anyone wants to go ahead and verify that this payment is valid, they can go ahead and use my public key from basically the referenced previous block to go ahead and decrypt the signature of this transaction and assuming it all comes out okay, it should show the hash of the previous block and then you know it was actually me who went ahead and created this transaction record because i'm the only one who should have my private key. 
	- Double Spending
		- Description
			- While the previous design is useful for tracking the ownership of a coin, there is nothing to stop a coin's owner from creating two transaction blocks double spending the same coin.
			- However, if we were to have a publicly visible ordered log of all transactions, the user on the receiving end of the transaction could see that the coin was previously spent, and reject the payment. This is challenging because typically ordering events requires some sort of central server!
		- Okay, so basically even though, you know, coins go ahead and create this record of where um you know a coin has been held throughout its kind of entire existence, it doesn't actually block double spending. You know, for example, there's nothing stopping me from creating two transaction records that spend that coin twice. So basically this is kind of where the blockchain comes in. We have to basically go ahead and create an ordering of events that everyone can see, so we know that once i've spent that coin once, I no longer have the coin and then anytime i try to create another transaction, spends it again, it can be rejected because we know it's not actually a valid transaction. 
	- Blockchain
		- Description
			- A set of blocks, acting as a public ledger (record of transactions) for all coins in the network, where each block contains:
				- A hash of the previous block in the chain
				- Some transactions
				- A nonce (used to prove validity of the block)
			- Each node keeps a copy of the blockchain, and every time a node wants to add a block, it must broadcast it to all the other nodes. Since all transactions will be in the blockchain, we can ensure that nobody will be able to double spend
		- So like i mentioned, this basically corresponds to this blockchain where a blockchain is a set of blocks or more so like a linked list of blocks which acts as a record of all the transactions for every single coin and each block contains basically the following. Again, a hash of the previous block in the chain, some transactions that are actually going to be kind of in the block and once that block gets put in the blockchain those transactions are considered valid, and then also this third thing called a [[nonce]] which i'll explain a little bit more but it's kind of used to prove the validity of the block and show that this block is actually valid to go in the blockchain. So every single node in the network, which can also be called a peer, keeps this local copy of a blockchain and every single time it goes and tries to add a block, it needs to go ahead and broadcast that block to every single other node in the blockchain which can go ahead and verify the validity of it and then add it locally to their own copies. Since every single transaction is going to be shown on the blockchain, like i mentioned before, no one can actually double spend 
- ![[Screenshot 2024-11-14 at 9.56.13 PM.png]]
	- Adding a Block
		- Description
			- Peer (node in network) receives new transactions and adds them into block
			- To add a block to the blockchain, the peer must mine the block
				- Use some amount of CPU power to determine the nonce (proof of work)
				- Find x such that hash(list_of_transactions, previous_block_hash, x) starts with n leading zeros
					- Parameter n can be adjusted over time to keep the rate of mined blocks relatively constant
			- After nonce is found, block is broadcast to other peers
		- Okay, so in order to actually go ahead and add a block, you have to do the following. A peer is going to receive a bunch of transactions and throw them into this block. Eventually, the pier is going to have to take the entire block and say i want to add this to the block chain. So before it can actually do that, it has to calculate the nonce and the nonce is calculated by doing some intensive cpu calculations which in bitcoin is known as proof of work. So what is this cpu intensive calculation, basically we have to find some value x such that the hash of the list of transactions which you know can basically be given a hash via a merkle tree, which i've mentioned in the past, you use the root of the merkle tree, the previous block hash and x starts with n leading zeros and so basically the only way to actually find this value x, is to go ahead and brute force this and so in addition to actually kind of adjust the difficulty of how much brute forcing needs to be done, the blockchain can actually adjust that parameter n to make it more difficult to actually go ahead and mine a block and this way they're able to kind of keep the transaction rate of you know new blocks being added to the blockchain relatively constant. So i believe in bitcoin, it's about one block every 10 minutes can be mined. Okay, and then additionally, once that nonce is found, the block can be broadcast to other peers and it's really easy to verify that block because well basically you really just have to check that the hash of the list of transactions, the previous block hash, and that nonce go ahead and start with n leading zeros 
	- Validating Blocks
		- Description
			- Once peers receive a block, they need to make sure it is valid:
				- Hash of the new block has the proper number of leading zeros
				- Previous block hash points to existing block in chain
				- Transactions in the block are valid
					- No other record for the coin has the same hash of a previous transaction
					- Valid transaction signature
		- So like i mentioned, that's kind of one step of validation, but there are others too. So like i said, the first step is just going ahead and making sure the hash starts with a bunch of leading zeros, the other thing is that the previous block hash actually points to an existing block in the chain, and hopefully to, you know, a block in the chain that's actually at the end of the chain and then more importantly, that the actual transactions in the block are valid. This is kind of what makes uh you know blockchain work is that you go through every single transaction, you say, well does the owner that's spending this coin actually still own the coin according to the blocks currently in the ledger? And if they do, then it's valid. Otherwise, you're going to go ahead and reject that block because it has some invalid transactions in there. Okay, and then additionally, peers basically will just go ahead and accept a block to their blockchain by basically adding it to their local copy of a blockchain and start trying to mine new blocks with this previously accepted block being used as the previous hash of any new block that they might mine. So that way, this kind of gets integrated. 
	- Forks in the Blockchain
		- Description
			- Sometimes, there are times where forks may arrive in the blockchain:
				- Two peers find the nonce of a block at the same time and so many nodes process them in different orders than others
				- One malicious peer sends a block to a subset of nodes and a different block to another subset
		- However, even though based on what i've said so far works for creating this kind of linked list of blocks, it's still possible for there to be forks in the blockchain. There are two main scenarios where this can happen. The first one is that two nodes in the network, which are called peers, may find the nonce of their own local, you know, block that they're creating at the same exact time and so nodes are going to process them in different orders, you know. If we have two blocks `a` and `b` that are recently created, some nodes may think `a` comes before `b`. Other nodes may think `b` comes before `a`, and as a result, we're going to have this fork. Another possibility is that one malicious peer, because they're trying to double spend, is going to send a block to a subset of nodes and then a different block to another subset of nodes and once it's processed by kind of both sets of nodes, now you can basically, you know, doubly spend a coin which is going to be very bad. But, there's a way for bitcoin to actually go ahead and make sure that at least, eventually, it's going to be the case that you can only spend coins one time. 
	- Resolving Conflicts
		- Description
			- Peers will continue to add blocks to whichever branch of the fork that they received first. However, if it sees that another branch has gotten longer, it will abandon its current shorter branch and use the end of the other branch as the previous block for any new blocks it creates.
			- Double spending is technically possible during this time. However, most parties that accept bitcoin will wait until a few blocks have been processed after the one holding a given transaction in order to ensure that it is likely the transaction will stay in the blockchain.
		- So the way they do that, is they resolve conflicts by keeping the longest possible chain. So basically, peers are going to have these forks and um this is possible which is totally fine, however, it's going to basically keep working on the fork that it received first and the second that it sees another branch of the fork has actually gotten longer than the branch that it's been working on, it's going to go ahead and abandon the branch that it's currently working on and start creating new blocks that are linked to the end of that longer branch and this way, every single peer in the network is eventually just going to make sure that they're working on only the longer branch and as a result of that, they're all going to eventually be consistent. During this time, double spending is technically possible. However, the way that most bitcoin clients actually work are that they wait for a few blocks to actually go ahead and be added to the end of a given block so that they know that it's very likely that this transaction is actually valid because most kind of invalid blocks that create a fork are going to be ditched after a couple of iterations.
- ![[Screenshot 2024-11-14 at 10.01.06 PM.png]]
	- Conclusion
		- Description
			- Bitcoin is an extremely interesting culmination of a lot of concepts that we have studied, such as building ordered logs, using hashes, and resolving conflicts. However, it has its downsides as well. Bitcoin is extremely slow due to its insistence on only mining a block once per ten minutes, and additionally extremely resource intensive (wasteful) due to causing computers to use a bunch of CPU cycles to not accomplish anything. As a result, many alternative blockchain implementations have sprung up trying to fix these problems, as well as add new features to the blockchain to support items beyond just cryptocurrency.
		- Okay in conclusion, bitcoin's a really awesome technology as is blockchain and it's becoming very commonplace in our society. However, it obviously has its issues mainly surrounding both speed which i touched upon and also proof of work which is super wasteful of CPU resources. So as a result, a bunch of alternative implementations have basically popped up and they're starting to gain some ground as well. So i'm not really going to cover those on this channel because it's not a blockchain channel, but that being said it is something to further research and it's actually really cool to see how you know other blockchains have gone about avoiding this proof-of-work mechanism and used more clever solutions to not waste cpu resources and be a lot faster