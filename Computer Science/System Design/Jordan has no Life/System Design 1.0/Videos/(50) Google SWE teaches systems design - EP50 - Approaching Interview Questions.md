---
Source:
  - https://www.youtube.com/watch?v=IY2EPjShgc4
Reviewed: false
---
- ![[Screenshot 2024-11-15 at 2.04.23 AM.png]]
	- Introduction
		- I'm gonna go through basically all the super popular systems design interview questions and uh we'll get through it together, and i'll be using my good camera so that should be fun. Expect a video in early June, but for now, let's talk about how to actually go ahead and crack your systems design interview and the steps you should take in addressing any question.
	- Handling Interview Questions (Background)
		- Description
			- While it's important to have a bunch of knowledge surrounding systems, any successful interview is going to be predicted not just on possessing the knowledge, but also conveying it in an effective and concise manner. In this final video, let's discuss how to tackle an actual systems design interview
		- Okay, handling interview questions. So, basically, it's important to have a bunch of this knowledge surrounding systems design, so obviously you can talk about it in an interview. However, if you know you just have a jumbled mess of a design or don't kind of approach the problem in a systematic way, then you'll look dumb and unorganized and it seems like you're just not gonna be able to get your thoughts together. So let's talk about how to actually go ahead and approach an interview question because there is more or less a pretty accepted or proper way to do it.
	- Requirements Clarifications
		- Description
			- The most important part of any interview is figuring out which part of a service you are actually going to build. No one wants you to build all of Twitter or Facebook, but rather do a high level design of a small chunk.
			- Try to figure out what the interviewer wants you to focus on early on by asking:
				- The scale of the application in number of users, as well as the performance goals
					- If Twitter: are we optimizing for low latency tweets, or instead home page reads?
				- Functional requirements
					- If Twitter: can we post tweets, do we have DMs, do we have images?
		- Okay, the first thing is you are going to clarify the requirements of the problem. This is basically just going to say, well, what is it that you actually want me to design because the truth of the matter is that 90% of the time, all the services that you know someone might say in an interview question, hey design uber, right? Uber does a million things, you can't design all of uber in 45 minutes but you can design a pretty small part of it, you know, without going into too much detail. So you have to quickly hone in on what exactly it is that you want them to you know have you design and then basically, you know, kind of go from there and figure out all of the in-depth requirements from that. So, you should ask a couple of important questions, you know, obviously the scale, um ask for things like the number of users and the performance goals that you're getting, so you can kind of hone in on which part of the application you want to focus on and then additionally, functional requirements. So for example, you know, if we're told you know design twitter. That's huge, twitter has a ton going on. I'm not designing their ad back in, but, you know, can we post tweets, do we have DMs, do we have images, there are all these features of it, and you have to kind of figure out which ones to cut and which ones to keep because at the end of the day, your interviewer is only interested in a small part of them. 
	- Capacity Estimations
		- Description
			- It is important to get a sense of the scale of our application early on so that we can start to think about whether something like caching or partitioning is necessary.
			- Ask:
				- Ratio of reads or writes?
				- Number of users? Average size of each upload image?
			- From there, try to figure out the necessary amount of storage needed, and what the common use cases of most users is - because this is what we want to optimize for
		- Okay, next, capacity estimations. So this one, i still have trouble with myself just because, i don't know, it's kind of hard for me to convert data to actual bytes on a disk but try to just get a scale of how much data you're going to be storing based on the number of users that you have, based on the number of you know say operations that they're doing per day, the size of each operation, so you know, if you're up uploading a ton of images or image data, you know, try and get a good estimation for the size of an image. Maybe 10 megabytes, or you know, if it's video footage, maybe almost up to a gigabyte if it's high quality or something like that, you know, remember that a character is just two bytes, so if you're storing in 140 character tweet, it's probably around 300, so you know, keep in mind things like that. So additionally it's important to ask the ratio of reads to writes. The reasoning for this being that, you know, if you have a super read heavy application, the design is going to be very different than if you have a super write heavy application. If they say there's only one write per 100 reads, you're probably going to be optimizing for the common case which is reads. That being said, if reads are very infrequent or you're writing all the time, you're optimizing for the write case and that completely changes what type of database you might be using, and the design or maybe even the replication type that you're using. Additionally, it's important to know the number of daily users because, you know, that's kind of going to be multiplied by all of these other estimations in order to figure out the number of you know say gigabytes or terabytes that you need to store and by knowing things like the number of gigabytes or terabytes, then you can kind of start to talk about hey, this is the way that i need to partition, this is probably how many machines i have to partition on because, you know, a machine can say only have i don't know 10 terabytes of disk space per machine or maybe you know 128 gigabytes of ram on modern servers or things like that. So it's important to kind of get a sense for that there. 
	- API Definitions
		- Description
			- At this point, start coming up with some rest endpoint definitions that you will have in your service for the client to interact with - you can just list these out as function calls.
				- `create_user(email, password_hash)`
				- `send_tweet(user_id, text)`
			- They do not have to be super detailed, obviously in a real service they will be much more complicated
		- Okay, now we want to start talking about api definitions. So these don't have to be super formal, and you know, don't waste a lot of time here. They're supposed to generally be basic. But the point is at the end of the day, you're going to be exposing some services to clients, generally speaking, for most of these problems and when you do, you just want to come up with a really basic function definition for the type of things that your server might take in in order to basically go ahead and perform this operation. So again, back to the twitter example, if you're creating a user, you want an email and a hash of the password and similarly if you are going to be sending a tweet for example, you know, you just want the user ID and the text of the tweet. Obviously, in reality there's going to be a bunch of other stuff being passed into these functions, but for the purposes of an interview, don't waste time here, just write out some quick stuff
- ![[Screenshot 2024-11-15 at 2.18.14 AM.png]]
	- Data Tables
		- Description
			- Start thinking about schemas of data that you may want to store. This is something that may have to be modified a bit later once the design starts coming together, as it may turn out that the data store that you choose may be insufficient for a problem, and you have to rethink your schema.
			- Tweets Table:
				- User_id: int
				- Text: string
				- Timestamp: date
				- Metadata: json
		- Next, talk about data tables because although we don't necessarily have to have made a decision on which type of database to use yet, you do want some idea of the type of schema that you're holding, so you can keep in mind what information you'll have access to on a given endpoint call. Keep in mind, it's totally fine to have multiple database tables. That's very likely in reality, in fact, because we're probably going to be using a microservice architecture. So having many database tables is totally fine, you know, you can organize these however you want but you just want to be conscious of all of the things that we mentioned before, you know things like partitioning, replication etc, etc. But um yeah, just something for example like a tweets table here, pretty basic. There's obviously going to be a ton more stuff in reality but, you just want to put in the bare minimum more or less, and you know, it's fine to just mention that in reality, there would be much more.
	- Get Designing!
		- Description
			- For every single piece of the design, make sure to carefully inspect it to see that it is not a lone point of failure - and if so, make modifications to change this. In pretty much any systems design problem, expect to talk about the following:
				- Load balancing
				- Replication
				- Sharding
				- Database choice (sometimes multiple is the best answer!)
				- Using a microservices design
		- Okay, next we can actually start creating a design. So pretty much in any given design, the biggest thing to think about is, hey, how is my design going to be meeting my functional requirements and what your interviewer is going to do, is they are going to challenge you and basically go ahead and say, well, what if this is a performance bottleneck, what if this is a performance bottleneck. You know, what if this were to crash and so because of this, it's always important to think about the following things, it's going to come up in pretty much any systems design problem and that's going to be things like load balancing because obviously you need to ensure that your server is not getting overwhelmed, replication, sharding, choice of database and also probably just the general way that you split up your services. It's probably better to not use a monolith in a systems design round, and you know, if you can explain why it's useful to kind of use a microservices design, then by all means, you absolutely should. It's fine to have a complex design, you just want to be able to keep it relatively organized. 
	- You Will Get Grilled
		- Description
			- Remember, it is an interviewer's job not just to figure out what choices you would use, but rather why you used them. If you can't list the tradeoffs of any design choice that you made versus possible alternatives, you seem like you just memorized a solution. You don't have to have a perfect design, but you need to be able to justify what you came up with as a feasible solution
			- Often times, an interviewer comes into a problem wanting to focus on one aspect of it. Try to figure out what that aspect is early on, and then prove to them that you know about it.
		- Additionally, note, the interviewer's job is to grill you. They're not just going to sit there and nod their head while you write out some design on the board. What they're there to do is focus on one particular aspect of the problem and basically say to you, well why are you doing this? Did you think this edge case through, did you think this edge case through, and your job as the interviewer is to basically prove to them, hey i know what i'm talking about. How do you prove that you know what you're talking about? Well, you certainly don't just rattle out some design that you already memorized from, I don't know, grokking the system's design. Instead, what you do is you have to be able to list the trade-offs of what you picked versus what you didn't pick, and trade-offs are kind of the central concept of systems design. No one cares if you can design facebook messenger unless you know why you chose say WebSockets over long polling. It's important to be able to look at all the other options and say here's why i'm doing what i'm doing and not necessarily that it's 100% better because there's never no completely correct answer, but rather just you know this is why what i chose is valid and isn't completely infeasible. And so that's kind of the point of this interview, you have to show that you've been thinking through these edge cases and that the technology that you happen to choose for this problem is actually suitable for it as opposed to certain other technologies. It's possible that sometimes there will be a better technology and they even may mention that but as long as you can defend your choices to some extent, you should be okay. 
	-  Conclusion
		- Description
			- Good luck everyone, I'll start doing some interview problems and we'll get through it together!
		- Okay guys, um, I mean, that's kind of it for the systems design concept series. I'm going to start doing practice problems like i mentioned, and really grateful to all of you that have been watching so far. I hope you've learned a lot and i've been getting a lot of really great feedback, and yeah, start listing practice problems in the comments that you want me to cover. I'm probably gonna do the grokking ones first, but we'll get through it together and it's gonna be a good time, so i'll see you guys soon.