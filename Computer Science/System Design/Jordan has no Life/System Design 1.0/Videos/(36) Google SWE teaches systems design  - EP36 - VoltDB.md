---
Source:
  - https://www.youtube.com/watch?v=hoEhM9s3FNQ
---
- ![[Screenshot 2024-11-12 at 10.14.17 PM.png]]
	- Introduction
		- Hello everybody. I'm back again having a little sigma male 7 a.m recording session. Um today's video is going to be on [[VoltDB]]. Um I should probably just mention that there's like a small chance i'm not able to post tomorrow just because we're having like an entire school-wide party, and I'm going to be very inebriated the whole day. That being said, I'm going to do my best to try and find a little bit of extra time today to crank out one more video over the course of the day so that i can have it ready to be posted for tomorrow at five like normal. That being said, let's talk about VoltDB which is another cool concept. 
	- VoltDB (Background)
		- Description
			- VoltDB is another example of NewSQL database that uses a variety of optimizations in order to try to gain performance increases over traditional solutions such as MySQL or PostgreSQL
		- Okay, so VoltDB. What is it? Basically, um it's just a really quick background, it's yet another new sql database that i've actually mentioned a little bit in the past when talking about serializability and the reason that this one is kind of worth mentioning is because it takes a very interesting approach to serializability and that's how it's able to kind of optimize its performance over a traditional SQL database. 
	- VoltDB design philosophy
		- Description
			- Recall: Traditional SQL databases use two phase locking in order to implement transaction serializability, which leads to a variety of issues such as slow throughput due to locking, as well as the need to detect and revert possible deadlocks.
			- Instead, VoltDB has chosen to use actual serial execution: each database instance actually executes every operation in a single threaded manner, hence no locks are needed!
			- List
				- Sundar: smart
				- Elon: dumb
				- Jordan: genius
				- All towards CPU
		- So, what is the design philosophy of VoltDB? Well recall that traditional SQL databases tend to use two-phase locking so that means there's a bunch of shared and exclusive blocks on each row that are being you know both read and written by transactions and as a result, that means transactions often have to wait for one another. There's a ton of overhead to actually grabbing and releasing locks, and in addition to that, there's frequent deadlocks where two processes are waiting on the same resource and as a result, neither of them can actually go ahead and proceed. Instead, what VoltDB has actually done to simplify this entire process is actually just have each database running in a single threaded manner. As you can see below, it's basically just a queue of transactions which can be both reads and writes and the CPU on a given database node is just going to execute them in some serial order.
	- Supporting Single Threaded Execution
		- Description
			- In order to ensure that each database node is capable of running each operation as fast as possible (in order to avoid bottlenecks), VoltDB does the following:
				- All data stored in memory
				- Transactions must first be stored as stored procedures
		- And obviously what that does is it avoids the need to lock because you just have one process operating on things. So, uh, you know, just executing in a single threaded manner isn't going to be enough because you know just the fact that if you just took a single or a normal MySQL database, and we're just like okay, we're only going to use one thread, then it's going to just be super slow. So VoltDB obviously has to make other modifications to go ahead and actually support this design decision. So there are two major things that they do in order to kind of make this all work and the first is that all data is going to be stored in memory and the second are that transactions must first be stored as stored procedures. So i'm going to go ahead and go through those both in more detail right now.
	- Storing Data in Memory
		- Description
			- Storing data in memory eliminates disk stalls:
				- Less access to disk, no overhead moving pages from disk to page cache
				- Command log in conjunction with occasional snapshot ensures durability
					- Command log is similar to write ahead log, but has lower overhead because it just describes the transaction instructions themselves instead of the result (less load on disk)
					- Assuming that command log is updated synchronously, writes can be lost if updated concurrently with memory
		- So as far as storing data and memory goes, why would we want to do this? Well, for starters, it means there's no disk stalls. There's a ton of disk IO in databases that we have to wait on and just by putting everything in memory, we can actually go ahead and just mitigate this problem. Obviously RAM is more expensive and there's less of it to be had but the founders of VoltDB believe that in the modern day, you know, when you can have literally hundreds of gigabytes of memory on a single machine, it should be sufficient to actually store your database on there, and you know if you're out of space, you can probably end up sharding that anyways. Additionally, in order to ensure the durability of writes, VoltDB has something known as the command log where the command log is a little bit different than a write ahead log, however, it basically just says instead of storing the results of every transaction, it just stores the transaction instructions itself because it kind of reduces the overhead of writing to disk. Those disk writes can either be done synchronously or asynchronously. If they're done synchronously, you can be sure that all of your writes are durable because it means that everything is going to the disk before it's going into memory. If it's done asynchronously, those two are happening at the same time and then in theory some writes can be lost. But between that command log in conjunction with consistent snapshotting, you can be pretty certain that you're going ahead and getting durable writes. Um obviously again using memory is going to work much better with a single threaded database because you don't have to avoid or you don't have to go ahead and basically switch a bunch of disk pages into the memory cache all the time in order to modify them and then write back to disk. So avoiding all this disk IO and all this overhead involved is really huge for being able to run on a single thread 
	- Stored Procedures
		- Description
			- Using stored procedures eliminates user stalls:
				- Occurs in a read modify write transaction when a user has to perform some logic based on the original read, adds a bunch of latency to have to send query results/instructions multiple times over the network
				- Sending a single stored procedure ensures that all of the time spent in the transaction will be because of CPU cycles, not network latency
		- Okay, next, we have stored procedures. So um just to kind of remind everyone what a stored procedure is, a stored procedure is basically saying that for every single transaction, for every kind of block of code as opposed to going ahead and sending the database instructions uh one at a time over the network, you basically send it a block of database instructions that you know can take in something like a function argument because i believe VoltDB's stored procedures written in Java. So the point is you're basically going ahead and sending it a java function with some sort of callback that's actually going to be able to do read modify update transactions by using the result of that read and so this way what this means is that instead of having to read the database having all that data come back over the network while the database is basically just waiting for the user to respond with something else and then tell the database what to do, the database from the get-go is familiar with what it needs to do regardless of what that first read value comes up with. So as a result, stored procedure stops something known as user stalls which is basically waiting for the network on these kind of you know multi-statement transactions where there's some logic as for what to do after a given read. Um, so that way, basically between the memory and the stored procedures, we can basically ensure that all of the time spent in our, you know, our database or any time that it takes for an operation to happen, is simply just because of the cpu cycles being devoted to it as opposed to something like disk IO or network IO.
	- Partitioning and Replication
		- Description
			- Because data can only be stored in memory, it is more or less inevitable that the dataset will need to be sharded
				- Transactions that reach multiple shards will use one of the nodes as a coordinator node
				- In an ideal world, the majority of transactions will be on just one node
				- For some tables that are small but frequently joined on, it makes sense to keep them whole and store them on the same nodes that hold some partitions
			- Replication can be done both in a single leader manner or multi-leader manner for cross datacenter operations
				- In the event of multi leader replication, conflicts are resolved by giving deletes precedents over inserts, and if there are two conflicting inserts or updates, using last write wins
		- Okay, so let's quickly touch upon the partitioning and replication of VoltDB. Basically since data is only stored in memory, we know that we can't store that much of it on a given node, and so it's pretty inevitable that it's going to be sharded and you would shard that like a pretty traditional MySQL database or any other relational database where it's probably just going to be done on the primary key of a row. So any transaction that is going to be reaching multiple shards, basically the first thing that happens is the transaction is going to reach one shard and then that shard acts as a coordinator node. So for reads it's going to kind of go ahead and parallelize those read requests and then combine them together and for writes it's probably going to have to use something like two-phase commit or some other atomic commit protocol. The VoltDB creators do basically say that in an ideal world, the majority of the transactions are going to happen on one partition which is pretty much the case for all databases, you want to minimize the network latency involved and in order to do that what they allow you to do which is kind of interesting is for certain tables you know say you have a really small table but you know that you're constantly going to be joining on that table for most of these partitions, you can actually just go ahead and replicate the entirety of that small table to every single node so that way you could reduce the network latency when making those joins. It's almost kind of reminiscent of like broadcast hash joins in streaming I believe where you just take an entire copy of a table and load it into memory for really quick joins. Then finally we should note that replication can be done both in terms of just like a traditional single leader sense where you can have kind of those read-only replicas but also they allow you to do cross-data center replication using a multi-leader configuration and what that means is that you're going to be introduced to write conflicts and in the event that those happen, basically VoltDB says if we have two operations that are blatantly conflicting and one of them is either an insert or an update and the other is a delete, the delete always has precedence and in the event that neither of them is a delete, basically use the last write wins operation by choosing the one with the later timestamp. 
- ![[Screenshot 2024-11-12 at 10.46.48 PM.png]]
	- Conclusion
		- Description
			- By removing locks, VoltDB is able to achieve extremely high performance, even more so than in-memory key value stores (which still may use locking to some extent for lightweight transactions).
			- While VoltDB itself isn't overly useful for system design interviews, it is a great case study in how actual just using a single threaded database can be feasible under certain circumstances!
		- Okay, so in conclusion, we can see that VoltDB is yet another NewSQL database that chooses to optimize on the existing SQL design by targeting two-phase locking. We saw this with Spanner as well because Spanner is kind of designed for those huge read-only queries where having to hold locks on all the rows that you're reading in order to get snapshot consistency is extremely inefficient. So VoltDB actually goes ahead and performs this by literally just running through all operations on each node one at a time. It's rather interesting how they do this kind of just by keeping everything in memory and then using those stored procedures. So it's definitely a little bit of an unfamiliar design, however, it is extremely fast in the sense that um they were able to get this working really well and so i think it's worth talking about and it is a good case study on actual serial execution and kind of what you need to do in order to support that type of workload.