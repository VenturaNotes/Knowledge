---
Source:
  - https://www.youtube.com/watch?v=uOKrTc3Q0D0
Reviewed: false
---
- ![[Screenshot 2024-11-14 at 9.17.04 PM.png]]
	- Introduction
		- Today the subject is going to be about operational transform, also just another quick logistical thing, probably around episode 50, I'm going to stop posting daily because (A) i'm running out of things to literally talk about and (B) is that i want to start putting a little bit more thought into each video and raise the quality because i feel like beyond a point, you're not going to get subscribers if you're just posting these crappy little powerpoints every day like i've been doing and i kind of want to put more thought into the actual interview questions that i'm going to you know be starting to do soon. So anyways without further ado, let's get into the actual video.
	- Collaborative Text Editing
		- Description
			- Many platforms nowadays support collaborative editing, a method of two users being able to edit the same piece of text (or maybe some other form of data such as a calendar) at once (or perhaps when the device is offline) and avoid conflicts while also keeping both users' changes.
			- See Google Docs, VSCode, Google Calendar
		- Okay, collaborative text editing, what is it? Well, basically there are a ton of platforms nowadays such as google drive, google calendar, VS code collaborative editing that basically allow a bunch of different clients to simultaneously make changes to one piece of data whether that's a text document, whether it's a calendar, you know an IDE for code writing and so as a result of that, you know, it's literally just a recipe for disaster and conflict in the sense that, you know, you're going to have all of these conflicting writes and you're going to have to rectify them somehow such that they actually make sense to every single user and such that each document actually converges to a consistent state. But keeping that in mind, you know this is a lot easier said than done and we're going to see how you know kind of having to deal with an array of text or maybe calendar events or something like that and getting that to converge is a little bit harder than your typical CRDT problem.
	- The Problem
		- Description
			- Array writes are not commutative!
				- Example shows not the same!
		- Okay, so here is the big problem which is that array writes are not actually commutative. So imagine we have two devices, you know they both start out with "poo" and now they're going to make a change locally and then it's going to get propagated to the other device. So we've got "poo". First one is going to insert "s" at position zero and the other one is going to insert "p" at position three so we've got `spoo` on top and `poop` at the bottom and now they're going to send their changes to one another. Now we've got `spopo` and `spoop` after basically doing those same insertions. As you can see, the documents are not in a consistent state so how can we actually get it so that they are because otherwise this wouldn't make sense to anyone. 
	- Solution: [[Operational Transform]]
		- Description
			- Transformation function T converts the ordered operations into the proper array such that each local copy of the document converges in the way that it is supposed to.
			- T is a very complicated function with lots of edge cases
		- Well one solution is to use something called operational transform. Operational transform basically accepts the fact that these devices are going to go ahead and make their relative changes and then it's going to consider all of the changes at one time and use this transformation function `t` which, you know, I'm going to keep as an abstraction for now but just know that between formatting, deleting characters, all this stuff, it's a very complicated function, `t` is basically going to take one operation given all of the operations that have preceded it and transform it in a manner such that it makes sense. So as you can see, we've got both of these documents starting out the same way with just `b` and `c` but then once you insert position `a` at position zero and `d` at position two, then the subsequent operations actually have to be modified a little bit. As you can see, now on the left side, um inserting `d` at position two is actually going to have to be modified to inserting `d` at position 3. And that's the only way these two can stay consistent. So like i said it's obviously a complicated function, you can start to even think about some of the edge cases that are going to arise, but this is something that actually works and it's used in something like google docs.
	- Pitfalls of Operational Transform
		- Description
			- OT is a perfectly functional algorithm - in fact it is used in Google Docs!
			- However, for the function to work as it is supposed to, it requires that all of the updates have a total order to them, which requires either a single leader for ordering them or some sort of consensus algorithm. This makes it slow. What if we could have some sort of data structure that allows us to resolve document conflicts using commutative operations?
		- However, it also has its pitfalls. Mainly being that in order for this to work you have to have an ordering of those operations for that function `t` to actually understand the ordering and then transform every operation as necessary. So as a result of that, what it means is that every single operation made to a given document has to either go through a single leader or some sort of consensus algorithm in order to get some sort of replicated um sorted log and as a result of that, that is going to make things pretty slow. So if you have hundreds maybe even millions of users trying to make changes to the same exact place, it's going to take a really long time or it's going to be hard because the throughput of one single leader node might not be sufficient there. 
- ![[Screenshot 2024-11-14 at 9.29.55 PM.png]]
	- Text Editing CRDTs
		- Description
			- Recall: Conflict Free Replicated Data Types are either based on passing state or operations from one node to others, in a way that each node can eventually converge to the same state. In particular, operation based CRDTs could make a lot of sense for text editing because having to send the entire document over the network would incur a lot of latency
		- Okay, so what is another option. Well actually this is kind of newer and it's more of an up and coming thing but we'll actually see text editing CRDTs. So if you recall from my previous video what a CRDT is and if you don't you, should probably go watch that, a CRDT is basically some sort of data structure that each replica can hold locally and basically every single time there's a change, you can either pass the entire state of that data structure, or you can just pass that operation that actually modified it and the entire point is that you use CRDTs in order to make sure that every single replica converges to the same value of the CRDT and so this is something that could potentially work really well for text editing. However, it's not as easy as something like a CRDT for a set or a counter because there's a lot of nuance to text editing in the sense that array operations are not commutative and kind of the entire huge thing about CRDTs that makes them work so well is that generally they work with commutative data structures. For example, adding elements to a set is commutative. Adding increments to a counter is commutative, but it's not so easy with something like an array. So how can we go ahead and actually make this work? 
	- Text Editing CRDTs continued
		- Description
			- A document consists of a set of (char, location) tuples. To insert a new character between two other characters, pick a number between the locations of the two neighboring characters. To reconstruct the document, simply sort the set by the location parameter of each tuple.
				- Requires causal broadcast for deletes
		- Well, this is where we are going to use the following strategy. So basically each document is going to be more or less represented as a set of character and location tuples. So if you look at the diagram here on the right, basically each document is going to start out the same way. We've got `b` and `c` at certain positions and then we've got this start and end token at you know position 0 and 1 and we're going to model every single character in the document from position zero to one. So now what happens is that when you insert um a character between two letters, you're going to go ahead and take the positions of um you know kind of the neighboring letters of this insertion, so if you're looking at inserting `a` here between the start character and `b`, the reason we're going to get 0.25 is because we go ahead and take the halfway point of the start character in `b` which is 0.5 over 2. And then similarly for `d`, if we're inserting that between `c` and the end character, we're going to go ahead and do 1.0 plus 0.75 and then divide that by two. And that way, when these operations are actually going ahead and going to be sent to one another, their position relative to everything else is going to actually be kept. Now if you think about it, there are a ton of intricacies within here that i'm purposely not going over because similarly to operational transform, there are tons of edge cases. For example, you know what if user `a` and `b` put you know two characters in the same location but they were actually just different characters. You know how would we resolve that conflict? The the answer is there are a variety of different ways of doing it. One of them would be to just kind of decide an arbitrarily like last character wins based on some sort of node order and you know there are obviously going to be a ton of intricacies based on things like formatting, um floating point precision can become an issue if you're dividing by two too many times, you know you're losing the precision that you need in huge documents. So there are obviously going to be intricacies here and then especially there are going to be intricacies if, you know, you write like 10 characters at once in one document, 10 characters at once in the other document, you need to make sure that those 10 characters are going to stay, you know right next to one another and be subsequent as opposed to you know like interleaving those like the fingers of my hand going like this, what we want is here. You know five characters like this, five characters like this, and not all mixed together. So ultimately, this is definitely still an ongoing field of research but the reason it's so useful is that it doesn't require a total order broadcast but instead rather just something like a causal broadcast in the event that, you know, you want to insert a character and then delete it afterwards, it's important that you know the document realizes that the character was actually inserted before it got deleted and the way you could do something like this is just by using something like a lamport timestamp, which as we know is pretty lightweight. So being able to use text editing CRDTs is a lot more scalable because it doesn't require some sort of centralized server to have to go ahead and order all of these writes. And so as a result, like i mentioned this is a really interesting field of research and it's something that will probably start coming into play in subsequent years.
	- Conclusion
		- Description
			- Being able to deal with real time collaboration is extremely difficult as there are all different types of conflicts that may come up, and it is not enough for the documents to converge to the same state - they also need to make sense when they do. As a result, there are a ton of different intricacies to making something like operational transform or a text based CRDT work, but as we can see based on the success of Google Docs, it is certainly possible!
		- Okay, so overall as we know being able to deal with merge conflicts or just conflicts in general when you have a bunch of replicas is really difficult and it's especially difficult when you have it in a way that commutative operations are not actually going to preserve that state, right? You're going to not have convergent state if you don't have a clever solution to this problem, but that being said, obviously companies have been able to kind of get these solutions to work. Like i mentioned, operational transform is used in Google and as a result of that, we can see systems like google docs which actually work really well at pretty large scale, but even still you know there's a ton of ongoing research about this field in things like text editing CRDTs and i'm 100% sure that even though this is a pretty theoretical field, that people have definitely been asked systems design questions about this topic before. In fact, someone even commented that they've been asked about operational transform and as a result of that, I think it's pretty important to cover and it's a super useful topic