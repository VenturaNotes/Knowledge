---
Source:
  - https://www.youtube.com/watch?v=ZEh0A6O72Kw
---
- ![[Screenshot 2024-11-12 at 9.25.33 PM.png]]
	- Introduction
		- hello everybody, I am back for another video and today is going to be about [[MongoDB]]. I've got probably about 15 minutes to record before my roommate comes back and catches me in the process. That being said, 15 minutes is a lot for me because typically it takes me about 30 seconds to get finished in most aspects of my life. So with that being said let's talk about MongoDB. Sorry, I probably should have made this video a while ago but i kept like looking at Mongo and being like, I don't understand why this deserves a video. So in some senses it doesn't, but it seems that a lot of companies still use it and for that reason, I'm going to talk about why they might do that
	- MongoDB (Background)
		- Description
			- MongoDB is yet another immensely popular NoSQL database widely used in industry. Compared to an RDBMS, or something with a much different intended use case such as Cassandra, it seems that MongoDB is a very flexible and middle of the road solution, such that developers have more freedom to use both some relational concepts in their data patterns, while still generally trying to keep denormalized data when possible.
		- Okay, MongoDB. What is it? Well basically MongoDB is another NoSQL database but this time as opposed to a bunch of the other ones that I've talked about, MongoDB actually uses a document oriented format which basically means that we've got collection of documents and data can be stored within those documents. It definitely has some pretty stark differences to something like either a relational database management system and also on the other end of the spectrum something like Cassandra where it kind of takes aspects of both and it really seems to position itself in like a major middle ground between all of the databases that we've covered so far. So i'm going to kind of describe the architectural choices that have gone into MongoDB that makes it kind of work that way and ultimately why it kind of acts as a jack of all trades type of database where its biggest utility is probably the fact that the lack of constraints on the type of operations you can do on the data means that you don't have to worry too much about future maintainability. You can kind of just throw your data in MongoDB and know that the majority of your functionality is probably going to be supported albeit maybe not at the fastest possible speeds. 
	- Data Format
		- Description
			- MongoDB is a document database - documents are stored within collections, and in turn each document itself can have other nested collections.
				- Note that documents do not follow a set schema: within a collection it is advisable to have generally similar documents but there is nothing enforcing a format, which allows for adjustable schemas over time!
			- Famous Actresses
		- Okay, so firstly let's talk about the data format. Like i mentioned, MongoDB stores its data in documents where documents are stored in collections. Each document can also have collections within it and then you can have sub-documents within those collections. So as you can see, I've put some of my favorite actresses below and we've got videos which are a sub collection which i didn't really bother to picture but you know the point is you can have other video documents in each of those sub collections. What that does is it greatly increases data locality. You can store a ton of information within this one document and as a result of that, you know if you need to access a ton of stuff unlike a relational database system where you know you may have to perform a join, you can actually just get all of that data in the same spot on disk. Additionally, do note that um the documents don't necessarily have a set schema even if I made it look that way right here. For example, I could definitely put other properties for each of these documents that are unique like, I don't know, maybe if i knew one of their heights, I could put the height there or their weight or something along those lines but the point is that being able to not have a set in stone schema is very useful for MongoDB because for developers who know that their application and the data that they're going to use is going to kind of evolve over time, having that flexible schema allows you to have some peace of mind that you're not going to have to do a major migration down the line or ever have downtime or anything like that.
	- Architectural Overview
		- Description
			- Within a collection, database partitions the documents based off of a shard key per record
			- Within each shard, availability is ensured via single leader replication
			- MongoDB uses a B-tree based storage engine
				- Prioritizes read speeds over write speeds
		- Okay, so in terms of the architectural overview, I'm kind of just going to breeze through this because we know what most of these topics are at this point and the point of this video for me personally is not to you know kind of discuss the inner workings of MongoDB but probably more so get to the bottom of why you have so many people using it and I'll i guess express my thesis towards the end. So anyways, obviously MongoDB can store a ton of data, so within a collection, if you have a ton of documents, you're probably going to have to partition them and you can do so by using something called a shard key where Mongo will auto generate this for you if you don't specify it. It's basically just like the ID of the document and that way it allows you to kind of express which document should go on the same partition which gives you some control over you know the locality of certain documents and maybe being able to access them in something like a range query. And then within each shard, you can use a single leader replication in these replication zones where you have all of these followers that are asynchronously getting changes from the single leader and if the leader were to go down, then the followers will go ahead and elect a new leader. It's important to note though that generally speaking MongoDB actually only performs the reads from the leader, so if the leader does go down, you may have a few seconds of downtime. You can actually configure MongoDB to not do that and just allow some stale reads from replicas in order to ever avoid that downtime though. Additionally as opposed to something like Cassandra which uses an LSM-tree based storage engine, MongoDB has chosen to stick with the traditional b-tree and that means that reads are going to be prioritized a little bit over writes so that's kind of more comparable to the traditional relational database setup. 
	- Cross Partition Operations
		- Description
			- Mongo enables multi document transactions (either over the same or different shards)
			- Mongo enables parallelized queries over the entire data set (over the network), can be sped up via the use of secondary indexes
				- Secondary indexes can be applied even on deeply nested data
		- Additionally, one cool thing that MongoDB lets you actually do unlike Cassandra is cross-partition operations. So this is where you get a little bit more freedom than kind of Cassandra's constrained model of everything needs to go on one partition and let's keep it there. So Mongo enables multi-document transactions which means you can make sure that multiple documents are either all atomically edited or you know not changed and that can either happen on the same or different shards which is you know, it's a nice functionality even if it's not the most efficient thing. Additionally, you can have parallelized secondary indexes and big queries over the entire data set, not just one shard like Cassandra and these powerful secondary indexes allow you to have a ton of flexibility within MongoDB to make queries as your data evolves over time. So you know as far as Cassandra goes, you generally have to really plan out how you're going to be using that database beforehand to make sure that your data is organized in a way that all of your operations are staying on one shard. On the other hand, with Mongo like i keep trying to mention, you have a lot more flexibility to kind of dump your data in there and maybe it won't be the most efficient query, but if you do need to get the data somehow, you can via all these types of secondary indexes 
- ![[Screenshot 2024-11-12 at 9.39.52 PM.png]]
	- MongoDB vs. Relational Databases
		- Description
			- In comparison to a relational database, MongoDB exhibits the following properties:
				- Flexible schema
				- The ability to design an application with data locality in mind via a highly nested document structure
				- Lack of normalized data may require having to change data in multiple places
		- Okay, so now let's actually do a quick comparison because like i've mentioned Mongo is definitely different than relational databases in the sense that you use a document data model which allows for not only a flexible schema but also much greater data locality if you want to store a bunch of individual records with one document. That means you can basically just have a many-to-one relationship and as opposed to running a join over possibly many nodes and a network connection, you can just have those stored all together. That being said, the fact that this is a NoSQL database means that data can be denormalized if you choose to do that and then in that event if you're going to make updates to certain data, you may have to make multiple updates and it's probably the case that you want to do those atomically or else you may have data inconsistencies.
	- MongoDB vs. Cassandra
		- Description
			- In comparison to a relational database, MongoDB exhibits the following properties:
				- More expressive document data model
					- Although with a bit of tinkering on a clustering key, you can effectively organize Cassandra rows in a subcollection type of ordering
				- The ability to query data using complicated secondary indexes, as well as making operations (both writes and queries) spanning multiple shards
				- B-Tree architecture is better for read throughput
				- Use of single leader replication and B-Tree as opposed to LSM trees and leaderless replication means that write throughput does not scale linearly to the number of nodes in the cluster
		- Compared to something like Cassandra, MongoDB definitely has its advantages and disadvantages. The biggest advantage is probably actually the data document model itself. Although I should note that you know if you're smart about kind of the design of your clustering keys and Cassandra, you can effectively just create your own sub-documents in Cassandra by you know using a clustering key that has like a prefix with a UUID for any given row and that way you can have them stored all adjacently next to one another. Additionally, the fact that you can perform more complicated queries not just on one partition but over many gives you a lot more flexibility within your database to make sure that you don't necessarily have to have everything figured out when you're first modeling out your data. You know, if it happens to be the case that, you know, at first that Cassandra model seemed great but then you realize you have some associations in your data that you want to be joining together, then Cassandra becomes really infeasible and you probably have to switch to an entirely different database. On the other hand, Mongo gives you that flexibility to kind of dynamically create queries as you go and through the life cycle of your application and as a result like I said it just gives the developer more flexibility and the ability to keep the application more maintainable. Additionally, that b-tree architecture unlike what Cassandra uses with SSTables and bloom filters, b-trees is a little bit better for performing reads. On the contrary, as you can see in red, but the fact that um MongoDB uses a B-tree architecture and the fact that it uses single leader replication, makes writes pretty significantly slower as opposed to Cassandra. That being said, you know if you kind of need the extra flexibility that Cassandra can't really provide you, you should probably go with MongoDB.
	- Conclusion
		- Description
			- Ultimately, it seems like MongoDB is a middle of the road solution - we use it when we want the ability to make complicated queries on data, but have a more flexible and expressive document model. Additionally, MongoDB is useful if we would like to use Cassandra for high write throughput, but ultimately our data access patterns do not allow us to keep all of our operations on just one shard.
			- In this sense, the architecture of MongoDB does not make it a "specialized" database for any specific type of task, but rather just an extremely flexible and intuitive one that has a large feature set while avoiding the pitfalls of relational data (compared to Cassandra and MySQL which are restrictive in their own ways).
		- Um, so here's kind of my conclusion is that obviously when i was looking at MongoDB's website and I just know from my own programming experience, MongoDB is an extremely popular database solution. That being said, it seems that the reason for this is the fact that it's kind of this nice middle ground between relational databases which are great for keeping data normalized and consistent and you know something like a multi-master leaderless database like Cassandra which is super optimized for performance and write throughput but only with a very specific data access pattern. In the case of Cassandra, it's kind of just over one shard. However what MongoDB allows you to do as a developer at least in practice is to be able to kind of you know model the data how you want but know that if you ever need to fall back on you know having to make a more inefficient query using something like um you know, local secondary indexes and then kind of combining those together in parallel, you can do that. So you have this kind of greater set of functionality. That being said, as far as for systems design interviews, I can't imagine that for the most part, MongoDB is going to be the best answer to ever give. That's because in systems design interviews, you're not thinking about the maintainability of the application as much as you are how to solve a problem at a given level of scale, right? In every single systems design interview, your interviewer is going to say this is how many users you have, not this is how many users you have now and you know in the future expect this to double or at least in my experience that hasn't been the case, maybe it can be. But the point is assuming that you're just tackling one problem in the systems design interview, typically there's probably going to be a more specialized database solution that's going to work better than MongoDB. That being said though, in practice, you know, if you're trying to get an application off the ground and you know that you're going to be growing over time, the scalability and advanced feature set of MongoDB does make it very useful. So i hope that this video was a nice introduction to document databases. I'll probably cover one more which i think is going to be [[Couchbase]] and then also one or two more NewSQL databases.
