---
Source:
  - https://www.youtube.com/watch?v=VXWcNGxKMq4
Reviewed: false
---
- ![[Screenshot 2024-11-11 at 1.20.29 AM.png]]
	- Introduction
		- hello everyone, um I am back for yet another video and this one is going to be about geospatial indexes. Um if you're wondering what a [[geospatial index]] is, let me uh give you an example of something. Let's imagine that we're on a website. I won't really talk about which ones but you see something that tells you that they're um you know 5 mile radius that are interested in you. Well um the only way they could actually do that uh in a decently efficient way is using something like a geospatial index. So we're going to go ahead and talk about how those work and break it down for you.
	- Geospatial Indexes (Background)
		- Description
			- In many applications, it is useful to be able to perform queries based on the location of a given point - for example, finding all objects within a certain distance (radius) of the original point. See Uber, Yelp, Tinder, etc.
			- As we know, quick querying in a database can be accomplished by creating an index - but in order to index geolocation data, we need to do some more sophisticated work. This is where geospatial indexes com in!
		- All righty geospatial indexes. What are they? Well basically in a ton of modern day applications, there's some sort of need to be able to do the following access pattern. We want to take one given point so maybe like a coordinate like a latitude and a longitude and find all of the other points in the database of perhaps a certain type that are within a certain distance of it. Probably by radius. So examples of this happening are Uber um in terms of you know finding a nearby driver Yelp in terms of finding nearby restaurants and Tinder in terms of finding nearby potential dating partners. Um as we know um querying in a database can be done with an index and that's kind of there to speed up both you know normal queries and range queries over one given column. However, um with geolocation data, we have to use something a little bit different or at least make a modification to the data itself in order to use indexes the same way as before. This is where geospatial indexes come in and I'll explain those now. 
	- Coordinate Data - The Problem
		- Description
			- Coordinates are expressed by a 2D tuple containing latitude and longitude.
		- So what's the problem with coordinate data? Why can't we just use a typical index? Well coordinates are typically expressed by a latitude, longitude tuple. So as you can see if we imagine latitude and longitude on this cartesian plane where latitude and longitude are each kind of one axis of it, we have all of these points. 
	- Coordinate Data - The Problem
		- Description
			- Let's find all the points within some distance x of the highlighted point!
		- Okay so now let's imagine that we want to find all of the points within some distance of that yellow highlighted point. So that would be those two points points in the circle there. Well basically what can we do? Imagine we had a traditional database and we have these two columns for each point latitude and longitude. 
	- Coordinate Data - The Problem
		- Description
			- Since `LatLng` is 2 dimensions, we can only have an index on one of them - imagine we first selected points based on latitude - we would then after have to check the longitude still in order to see if it falls in the circle.
		- Well I guess if we had an index on either latitude or longitude, what we could do is just go ahead and basically say okay, uh say the distance was 5 miles, um let's find all the points with a Latitude you know within like the Five Mile equivalent of that and then you know once we have all those points, we can go ahead and filter them out. Well the problem is in the real world there's a ton of points that are going to be within just you know a certain latitude value but not within also the right longitude value. So only having an index on one of these two Fields is very inefficient because it means that we find all these points but then we still have to go ahead and filter a ton of other points down and you know that could be Millions even perhaps uh tens of millions of points that we would basically just have to invalidate by using some sort of um you know like cartesian equation for finding the distance between those two points and it would be super inefficient. It's basically just a full table scan. So obviously that's not going to work. So what can we do that would actually take advantage of an index and allow us to quickly find all the points within a certain distance of one point. 
- ![[Screenshot 2024-11-11 at 1.30.15 AM.png]]
	- Coordinate Data - The Problem
		- Description
			- Ultimately, a traditional index is not really useful to us as in the worst case, we basically still have to perform a scan over most of the points to check manually if they are in the circle - instead let's find a better solution!
		- Um obviously we're going to have to look for a better solution here. 
	- Geohashing
		- Description
			- In comes geohashing, which maps areas of a 2d plane to a single string value!
		- So what we do instead is called geohashing. So geohashing um this kind of like a pretty simple overview of it. This isn't exactly how geohashing works but it's kind of the way that I'm going to summarize it and then you know if you do any research in the future, hopefully that'll make more sense to you. But basically the gist of geohashing is this. Imagine a map of the Earth which I'll just you know let's imagine it was a 2d plane right here again split into that longitude and latitude. You take every single section, divide them in some sort of way, hopefully relatively evenly or maybe by population or something like that and mark each section with a letter or a number, so just a character for now and we'll just call that the [[Geohash]] of the section. So as you can see at, imagine this is what um the entire world looks like. The whole map. So you know we might have Asia in the you know the K&L section, uh the US might be in the g&h section because that's going to be at least in the maps that I look on on the western part. So the point is though that we have this initial divide of the map but obviously this doesn't really describe uh areas particularly precisely, it just you know creates this map into huge chunks of you know massive geography. So what we can actually do is imagine I have this portion up here with uh the label letter "a". What I'm going to do is divide "a" into a bunch of subcategories. So imagine we zoomed in on "a" now. 
	- Geohashing
		- Description
			- Each region is split into subregions, which have an additional character per depth of subregion
		- The view would actually look like this. So we take "a", which is a rectangle and we divide it into all these subregions. And so the point of each sub region is that every single subregion is its parent region concatenated with one more character and each of the subregions are unique in terms of their strength. So this is going to you know continue downwards to a really really small size of region. So I obviously have a depth of two here but you know I could have a depth of three, I could have a depth of four, and every single time you just go ahead and take that parent node and then split it into a bunch of mini chunks which again you just add an additional unique character for each of those sub chunks. 
	- Geohashing continued
		- Description
			- As the length of the GeoHash increases, the size of the bounding box of the GeoHash decreases!
			- Now that we have discussed what a GeoHash is, how can we use it in an index?
		- So let's think about what that actually does. Basically as the length of the geohash increases, the size of the bounding box of the geohash decreases. So you can see on this chart to the right, we have all of these geohash lengths and the corresponding size of the bounding box or at least an approximation of the size of the bounding box. So basically now what we have are we have all these big regions and then all these subregions of the bigger regions where all the subregions are the bigger region concatenated with some string. Why does this work really well? Well, it all kind of pertains to the fact that that when you take all of that um all of the geohashes like in total and you order them, it means that similar points are going to be right next to one another in that ordering. So let's actually think about that.
- ![[Screenshot 2024-11-11 at 2.05.05 AM.png]]
	- Geospatial indexing
		- Description
			- Recall: Both B-trees and LSM Trees + SSTables allow us to execute fast range queries on the indexed field.
			- So if we want to find all points within a certain distance of a given point:
				- Convert original point to geohash
				- Figure out the size of the geohash depth that encapsulates the distance from the point that we want (using the table from the previous slide)
				- Truncate the geohash of the original point to the length figured out in the previous step
				- Use the index to figure out all of the points in the larger bounding box, and check which ones are actually within the proper radius
		- So this is kind of going to be the entire process of geospatial indexing right here and it's kind of based off that whole geohash idea. So if you recall both B-trees and LSM trees with the SStables allow us to execute really fast range queries based on an index field. So imagine here that the index field is going to actually be a geohash. It means that geohashes that are next to each other are probably going to be very close to one another in proximity in the actual world if they're next to one another in the index. So let's say now that we have a given point and we want to actually go ahead and find the points near it in our geospatial index. The first thing we're going to do is we're going to take our point which is probably a `LatLng` coordinate and convert it to a geohash and there are services to do this for us. Then what we want to go ahead and do is actually figure out the size of the geohash-depth that encapsulates the distance from the point that we want. So say you know we want to find um all points within a few miles, you know we could go ahead here and say oh maybe depth five looks good for us because you know it's 4.9 km squared. Probably most of the points that we want are going to be within the same geohash of depth five, but we'll talk about that uh in a second more so. So then we're going to take our geohash of the point that we're looking at and truncate it to the proper depth because we're going to go ahead and assume basically that all of the points that we're looking for are going to be within that bigger geohash that is going to encapsulate all of the nearby points with the appropriate size. And then finally, once we have that um bigger depth, we can go ahead and use our index and execute a range query to go ahead and quickly find all of the points inside of the bigger geohash and then once we get all those points, we probably have to go ahead and actually you know filter a few of them because obviously the size of the bounding box isn't perfect but it just, you know, greatly limits the field of points that we have to look at in order to see which ones to uh go ahead and check. But, I'm actually going to provide an example of this because I know that was all kind of abstract. 
	- Geospatial Indexing Continued
		- Description
			- Example: Find all points < 1km from (42.167, 12)
				- (1) Get geohash: `91vz62q`
				- (2) Get proper bounding box
					- (a) Geohash of length 5 has size $4.9km^2$
					- (b) So we want to find all points in `91vz6`
				- (3) Use index to find all points p where `91vz6 < p < 91vz7`
					- (a) This is a range query, super quick!
				- (4) May have to filter down the result of the range query a bit by calculating the actual distance between the original point and the found points
			- Note: In reality, the point may be towards the border of the bounding box, and as a result we may have to check the ranges of the bordering bounding boxes as well (so could be up to 9 separate range queries!)
		- Okay, so imagine we want to find all points that are less than a kilometer from this random latitude and longitude. Um so the first thing we're going to do is get the geohash of that. I'm assuming that you know there's just some API you can call to do that and uh that's not actually the real geohash of the point, I just made it up but whatever. So first of all, imagine we get this geohash. Then what we're going to do is get a proper bounding box. So, we're going to go ahead and say, okay, well the geohash of you know length 5 has a size 4.9 km squared. So if that's the case, all of the points that we want which are you know within a kilometer are probably going to be in the corresponding length 5 geohash. So all we're going to do is now truncate our original geohash to length 5 um and look at all points in `91VZ6` because that's truncated to length five. So now take a look at the diagram on the right. Basically we have our original point which was `91VZ62q`. Um we have its bounding geohash which is `91VZ62`, basically you just take away the `q`. And then if you take away the two there, we have `91VZ6` which encapsulates all of that. Um, keep in mind that like I said, even though we might just be looking at `91VZ6` here, in reality if you know the point we were looking at was really close to the border of `91vc6`, then maybe we'd have to look at a couple more neighboring nearby bounding boxes in order to find all of the points, so probably you know maybe like nine in total because you would want to look at the top one, the top left, the left, the bottom left, bottom, bottom right, right, and top right. But anyway for now let's just simplify it and say we're going to be looking at the one with the proper depth so that's going to be `91VZ6`. We know now that because of how geohashes work, that basically any single point inside of a geohash, so any single subregion inside of a region, is going to have a lexicographically greater ordering than it, right. So every single point inside of `91VZ6` is going to be greater than `91VZ6` when all of those strings are sorted and we also know that imagine there was another box uh on the same level as `91vc6` so like think of them as siblings, called `91vz7`, we know that the second a point is you know greater to or equal than `91vz7`, it's no longer in the `91vc6` sub-box. So what this means is that we can go ahead and execute a range query on our index saying give us all the points that lie between `91vc6` and `91vz7`. So this is a super quick thing. If we are using SStables, those are going to be sorted and we can go ahead and perform a binary search really easily and get the bounds of that range query and then the same goes for a b-tree which also allows you to perform that read in logarithmic time. As a result though, since obviously these boxes aren't like a perfectly tailored size for us, we may have to filter down the results of the actual range query a little bit but just compared to an index on either the latitude or the longitude, this is hugely efficient and much much faster. 
	- Distributed GeoSpatial Indexes
		- Description
			- How can we actually scale a geospatial index over multiple nodes? By partitioning!
			- Simply assign large chunks of an index (such as the box "a" and all of its children to one node, do the same to box "b" and all of its children). That way all nearby points will be on the same node.
		- Okay so let's talk about geospatial indexes in a distributed setting. Obviously in reality there's probably going to be a ton of data points. If you're Tinder or you're uber, you have a ton of cars, a ton of users and uh you know a ton of people looking for potential dates and as a result, you probably can't store all those on one machine. So obviously these are going to have to be partitioned somehow. The good thing is that geospatial indexes are actually really easy to partition because you can just basically go ahead and take any region and say okay, plop this region and all of its subregions accordingly onto one node and then you know so say that's going to be be like the New York Region and then I'll go ahead and say okay take the you know the box that contains Pennsylvania and all of the sub Pennsylvania nodes and put that on another region. So basically this kind of like tree structure of having all these subregions makes it so that it's super easy to go ahead and partition a geospatial index and put um the data for one area on a different node than another area which is great and then obviously you can do stuff like replication and all of that. 
	- GeoSpatial Indexes in Practice
		- Description
			- Lyft uses Redis' geospatial indexes which use geohashes in order to keep them in memory for great performance
			- Uber has created their own type of geospatial index called H3, which is very similar to the geohashing approach that we have spoken about, but uses hexagons instead of rectangles and squares in order to help better figure out what other cells should be queried when finding all points in a given radius.
		- Okay, in practice, how do geospatial indexes actually look? What type of Hardware they are used on? Well it seems like for ride sharing companies like Lyft, Lyft tends to use something like Redis for geospatial indexes because they actually have a service that builds it into Redis and um that means that they're probably going to be kept in memory and really fast so that you can constantly query um the service in order to see your distance from the driver, see the driver's current location etc etc which is great and then in addition Uber kind of has created their own type of geospatial index which is very similar to geohashing but as opposed to doing it with um rectangular boxes, it actually uses hexagons. Uh the reason they do this is so that you know if you say uh from this given point, I want to find all points within a certain radius, um the kind of a hexagon with a bunch of surrounding hexagons is a lot better for resembling a circle and that way you can kind of more easily check other hexagon cells to see relevant points, so it's I guess it's just a little bit more more intuitive. Um I'll put a link in the description if you guys want to read more about that.
- ![[Screenshot 2024-11-11 at 2.21.48 AM.png]]
	- GeoSpatial Indexes for Shapes?
		- Description
			- Note: If you see databases that are indexing full polygon shapes (as opposed to just points), these are unlikely to be using geohashes. Instead, they use another similar but more complicated type of structure known as [[R-trees]]!
		- Um, what about geospatial indexes in terms of indexing shapes or polygons. Um sometime there are services that kind of want to be able to, you know, store a bunch of polygon data um and you know put those on a map and that's kind of how a lot of maps are built out. But actually speaking, they are unlikely to use geohashes. Um geohashes are mainly optimized for just kind of indexing points and being able to find a bunch of points that are near one another but if you actually want to store shapes themselves, you're better off using this more complex structure called an r-tree. Um there are similarities to geohashes but at the end of the day, it looks like in r-trees, you can actually have overlapping boxes which is not possible in geohashing. Uh maybe I'll make a video about that in the future but for now it's a pretty complex topic and it's not necessarily something that I think we need to know.
	- Conclusion
		- Description
			- GeoSpatial indexing is a must have for any application that heavily relies on finding objects with similar location. If you are ever asked to build some sort of real estate service, hotel finder, or localized dating app, you now know what to say!
			- By converting each two dimensional coordinate to a one-dimensional hash with a hierarchical structure, we can quickly perform range queries on GeoSpatial data via an index
		- Okay, so in conclusion geospatial indexing is hugely important for any uh application that's going to hold a ton of geographic data. As opposed to just using a typical 2D coordinate in order to make queries, it hashes these to one single value which it can then make really efficient range queries on. Um overall I hope this is pretty helpful because there are a bunch of systems designed questions that ask you to build Services um that involve ride sharing or online localized dating or even just review services but in a localized Manner. And as a result of that, it's probably pretty important that you know how geohashes work so that you can actually go ahead and talk about them. Um as always I'll put more data or more information in the description of the video so that you guys can read more about it. Um but yeah. I hope this one was useful and I look forward to continuing to talk about new content
