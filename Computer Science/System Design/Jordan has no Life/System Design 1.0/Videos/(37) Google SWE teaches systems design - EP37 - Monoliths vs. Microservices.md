---
Source:
  - https://www.youtube.com/watch?v=YSA9BcrAehA
Reviewed: false
---
- ![[Screenshot 2024-11-12 at 11.30.05 PM.png]]
	- Introduction
		- So today we're going to talk about [[microservices]]. Doesn't really make sense with the general ordering that i've been trying to keep up but i kind of threw that one out the window a little bit ago in order to keep doing daily uploads, so you know whatever. 
	- [[Microservices Architecture]] (Background)
		- Description
			- In many system design questions, you will have to design a good amount of functionality for some hypothetical use case. typically, it makes sense to split each piece of function into separate microservices, which act as self contained units of servers that can interact with other microservices as if they were external services.
		- Okay so what is a microservices architecture. I'm sure you've probably heard of this term before but in the event that you haven't, basically in a lot of systems design interviews, you're asked to kind of design a huge set of functionality. You know maybe if you're talking about Tinder, you're designing both the messaging, the matching, the actual creating and deleting and locking in of accounts and so basically there's all this super disjoint functionality that you're supposed to design together and typically speaking using something like a microservice architecture, those are going to kind of be self-contained services so that you can have teams working on them individually. But in order to kind of talk about why you want to be using microservices and understand the reasoning for that, let's first look at a [[monolith architecture]] and discuss kind of the shortcomings that it may have.
	- Original Approach: Monoliths
		- Description
			- All code contained in the same repository, same set of nodes in a cluster responsible for handling any possible application request
			- Monolithic Architecture:
				- User Interface, Business Layer, Data Interface $\leftrightarrow$ DB
		- Okay, so this is kind of the original approach that um you know most technology sites used probably 10 to 20 years ago. The reasoning being that they are simple to implement and sites didn't really have the scale that they might have needed in order to require doing something else. So kind of the logic behind this is that all code is more or less contained in the same repository. You basically just have one centralized backend application and then that way the same set of nodes in any cluster is just going to be responsible for only running that single application. So as you can see here in the diagram to the right, we have you know all these different types of logic. There's this logic for handling users, this logic for handling business i guess analytics, and then also for data stuff but they're all kind of packaged together into one back-end application and they're all touching this one centralized database. 
	- Benefits of a Monolith Approach
		- Description
			- Easy to implement
				- Do not need to think about how to split up functionality
				- All code goes in the same repository
			- Easy to test
				- As opposed to using blackbox testing with other microservices, can transparently make sure that everything works properly via unit tests in one repository
			- Easy to deploy and scale
				- Only one repository to deploy
				- If we need more compute, we simply redeploy the same repository on other nodes
		- So what are the benefits of a monolith approach? Well there actually are a decent amount and there's a reason that people are still using them. For starters, it's just easier to implement. There's no added complexity in splitting up your services into a bunch of different kind of logical groups and additionally all code goes into the same repository so there's kind of only one git repo to have to actually look after. Another useful thing is that it's super easy to test so as opposed to basically running unit tests that rely on other external services and say like well I hope this one works and kind of mocking that away, what you can actually do is do a full end-to-end test because all the code is present so you can go ahead and actually run everything like normal. Then finally, it's relatively easy to deploy and scale since there's only one repository, you only have to deploy one thing and then as far as scale goes, you basically just go ahead and deploy that same repository on more nodes. Obviously if you're thinking about this for a little bit, this has its downsides too but i'll discuss that right now.
	- Cons of a Monolith Approach
		- Description
			- Large application codebase makes it harder to onboard new developers
			- Deployments are huge and likely take a while
			- Harder for multiple teams to work on at the same time
				- Too many code changes to merge in
				- One team may introduce bugs that block another team working on unrelated things, or worse yet bring down the entire production service
				- Every small change requires a complete redeploy (which are slow)
			- Pieces of the service that differ in popularity cannot be scaled independently
			- Wanting to use a new technology or framework requires rewriting the entire monolith, as opposed to just a small piece of it
		- So you can see there's a pretty dense slide here and that's because there are a lot of cons of you know using monoliths. So the first one is just in terms of maintainability and organization of the code. The fact that you have this huge application code base makes it really hard to maintain. If you have a bunch of developers working on something, they're going to be writing in different styles and it's going to be harder to keep consistent and additionally any new developer that kind of tries to jump into this monolith and start getting working is going to have a harder time getting adjusted to that. Additionally and this is probably the biggest issue, is that deployments are huge and they take a while. If you make a single code change, you're going to have to redeploy your entire monolith and that means that you're going to have a ton of downtime for that service and that's not just you know say a two percent chunk of your entire company, that's a hundred percent of your company for potentially just a small change. Additionally, it's pretty hard for multiple teams to kind of work on um a monolith at the same time. Why? Because they're all working in different areas and so you're gonna have a ton of code to merge in. If one team makes a bug and accidentally merges that in because they were doing a bad job testing, that can totally block another team because the code won't compile and the other team will have no idea why because, you know, they're not the ones writing that code, they have no clue what the other team did. And then finally like i mentioned, you know, even small changes are just going to require a complete redeploy which are going to be super duper slow. Okay next in terms of actually scaling, I mentioned that monoliths are easy to scale because you just take that one service or that one back-end application and put it on more nodes. Well that's true, but it also means that for example if you are, I don't know like Facebook and you have all these different services and say Facebook shopping is starting to get really popular, while the newsfeed has similar load to before, you just want to be able to scale out the part of your service that is getting more popular because otherwise you're just wasting a ton of compute by scaling out your entire application linearly. So obviously you want to be able to kind of do independent scaling on pieces of your application at once. And then finally, this is another huge deal is that imagine we have this entire site and the back end is written in java and then you know someone comes along and says wait a second, kotlin is actually better. We like that language. Well, if it's a monolith, you're going to have to go write that entire thing so that is not going to work if you want to do some sort of agile development. It would probably be better if you could kind of split your service into chunks and only rewrite pieces at a time and get that done gradually because each team has different priorities. 
- ![[Screenshot 2024-11-12 at 11.48.27 PM.png]]
	- Microservice Architectures
		- Description
			- Teams each manage a few self-contained services that can be deployed and scaled independently, using a tech stack of their choice. This is far more scalable and solves all of the major issues mentioned regarding monoliths in the previous slide, at the cost of adding some complexity to your application layout.
			- Microservices Architecture
				- UI $\to$ Microservice $\to$ DB
		- This is obviously where microservice architectures come in. So if you look at the diagram on the right, we have this one centralized user interface that you know the front-end user is seeing and then on the back-end we have all of these different mini kind of back-end applications that are capable of communicating with each other and then even have their own separate databases for just the portion of data that they're responsible for holding. Generally speaking, these guys just use rest endpoints or http endpoints to communicate with one another although i'm sure some services use soap. I think while i was at Amazon, that's what they were doing there. And so as a result of that, kind of each of these microservices treats one another as if it were its own independent unit of compute and as a result each microservice can be you know developed independently by each team deployed and scaled independently by each team and using a tech stack that each team is most comfortable with. So like i said, this honestly goes super far in terms of fixing the problems that i mentioned in the previous slide. 
	- Quick Aside: [[Docker]]
		- Description
			- Very relevant for microservice architectures:
				- Applications are packaged into "containers"
					- Each container holds all of the dependencies of an application, as well as their versions, so that the environment that the application will run on is the same whether the code is running locally on a laptop, in a testing environment, or in a production environment on the cloud
				- When deploying to a cloud, you typically preconfigure the capacity of the virtual machine that you want
					- If we wanted a microservice running on each virtual machine, we would have to figure out the capacity that each service needed in advanced, likely would lead to much wasted compute
					- Docker allows running multiple containers on just one virtual machine (acts like a lightweight operating system), giving each container the ability to take the resources that they need in a given moment, leads to far less waste of compute power
		- Um just in terms of a quick aside because i feel like i'm probably not going to have another chance to mention this again on the channel at least anytime soon and i want to be able to kind of bring it up once in the event that it comes up in a systems design interview. Because so many companies have now started moving to these microservice architectures, this is where something like docker comes in which is super useful. Now if you haven't heard of it, docker is actually a [[DevOps tool]] which means that it's really important for actually deploying your code and kind of managing it but not necessarily adding extra functionality to your code itself. But it's extremely relevant for microservice architectures. So just as an overview of what docker is, docker takes your code or your back-end application or your background microservice and packages it into a container. So this is super useful because that container not only has the code itself, but all of its dependencies, libraries, and binaries that it relies on. So by virtue of this, it means that regardless of what environment you're running that code in, whether it's on your laptop and you're a developer or it's in the testing environment on the cloud or the production environment that you know people around the world are accessing, that code is going to be running using consistent dependencies that entire time and as a result, you're not going to have any like platform specific bugs which is huge. Additionally, and this is kind of where docker comes in to be so helpful for microservices is that it is effectively a lightweight operating system. So here's how that helps us. Generally speaking, since most applications are being deployed to some huge cloud these days where you have just gigantic server racks and the server can basically just be partitioned into virtual machines and you can figure how much capacity you want on each virtual machine, it would be really bad if we had say like i don't know imagine five or ten different microservices and then for each of those microservices, we had to configure a virtual machine. What if one of those microservices was either using too little or more resources than we thought that we needed for it and then as a result we're either going to be under kind of not using enough capacity in the virtual machine or we're even going to be wasting money by having given a certain microservice too big of a virtual machine. So instead what we can actually do is you configure this virtual machine. Just one, you throw a bunch of docker containers onto it and then the containers on their own can actually kind of scale up and scale down on that virtual machine in order to take just the resources that they need and as a result of this, if you're a company, this is great because it makes it super easy to just choose one value in terms of what you can afford to have in terms of compute and then the docker containers will kind of sort themselves out in terms of hey, microservice 1 gets a lot of compute. Microservice 2 gets less. 3 gets a medium amount. But generally speaking, that flexibility is huge because it means you don't have to pre-configure all of these virtual machines and waste a ton of money and waste a ton of compute. 
	- Conclusion
		- Description
			- While it generally makes sense for most new applications with a smaller team to start out under a monolith design to develop quickly and reduce added complexity, using a microservice architecture at scale is virtually a necessity. It allows teams to develop quickly on their own without a need for a unified codebase, and provides them with the ability to deploy and scale their service as they see fit. Finally, a bug introduced in the code by one team will not affect the services of another, and failures will be siloed
		- Okay, so in conclusion, if you're a small company or you're just starting out with one team, generally speaking that probably makes sense to use a monolith architecture just because you're not implementing a ton of functionality most likely and generally speaking, you don't want to develop for a bunch of scale that you don't yet have. It just tends to waste time and you may end up going back on that later. So sure, monoliths are fine there but for companies at huge scale like FANG companies or you know any of them with you know millions or even billions of users, generally speaking, kind of decoupling all of this functionality into their own separate microservices is something that can really speed up the development process as a whole and make it so that it's much easier to kind of have individual teams going and doing their own thing and then coming back together by virtue of wiring these microservices together. okay, i hope this one makes sense. It's not too complex of a thing, but in some systems design interviews, they'll want to kind of make sure that you understand why you're not just having an entire block of a service that gets deployed together. So um okay have a good one guys. I'm glad i can keep posting