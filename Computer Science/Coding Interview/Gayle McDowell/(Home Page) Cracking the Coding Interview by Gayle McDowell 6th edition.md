---
Source:
  - zotero://open-pdf/library/items/HZII393N?page=1&annotation=3TYC2L2L
  - https://www.crackingthecodinginterview.com/errata.html
Length: "708"
Progress: "0"
tags:
  - status/incomplete
  - type/textbook
Reviewed: false
---
## Introduction
## (1) The Interview Process
### (1.1) Why?
### (1.2) How Questions are Selected
### (1.3) It's All Relative
### (1.4) Frequently Asked Questions
## (2) Behind the Scenes
### (2.1) The Microsoft Interview
### (2.2) The Amazon Interview
### (2.3) The Google Interview
### (2.4) The Apple Interview
### (2.5) The Facebook Interview
### (2.6). The Palantir Interview
## (3) Special Situations
### (3.1) Experienced Candidates
### (3.2) Testers and SDETs
### (3.3) Product (and Program) Management
### (3.4) Dev Lead and Managers
### (3.5) Startups
### (3.6) Acquisitions and Acquihires
### (3.7) For Interviewers
## (4) Before the Interview
### (4.1) Getting the Right Experience
### (4.2) Writing a Great Resume
### (4.3) Preparation Map
## (5) Behavioral Questions
### (5.1) Interview Preparation Grid
### (5.2) Know Your Technical Projects
### (5.3) Responding to Behavioral Questions
### (5.4) So, tell me about yourself
## (6) Big O
### (6.1) An Analogy
### (6.2) Time Complexity
### (6.3) Space Complexity
### (6.4) Drop the Constants
### (6.5) Drop the Non-Dominant Terms
### (6.6) Multi-Part Algorithms: Add vs. Multiply
### (6.7) Amortized Time
### (6.8) Log N Runtimes
### (8.9) Recursive Runtimes
### (8.10) Examples and Exercises
## (7) Technical Questions
### (7.1) How to Prepare
### (7.2) What You Need to Know
### (7.3) Walking Through a Problem
### (7.4) Optimize & Solve Technique #1: Look for BUD
### (7.5) Optimize & Solve Technique #2: DIY (Do It Yourself)
### (7.6) Optimize & Solve Technique #3: Simplify and Generalize
### (7.7) Optimize & Solve Technique #4: Base Case and Build
### (7.8) Optimize & Solve Technique #5: Data Structure Brainstorm
### (7.9) Best Conceivable Runtime (BCR)
### (7.10) Handling Incorrect Answers
### (7.11) When You've Heard a Question Before
### (7.12) The "Perfect" Language for Interviews
### (7.13) What Good Coding Looks like
### (7.14) Don't Give Up!
## (8) The Offer and Beyond
### (8.1) Handling Offers and Rejection
### (8.2) Evaluating the Offer
### (8.3) Negotiation
### (8.4) On the job
## (9) Interview Questions
### Data Structures
#### (9.1) Arrays and Strings
##### (9.1.1) Hash Tables
##### (9.1.2) ArrayList & Resizable Arrays
##### (9.1.3) StringBuilder
#### (9.2) Linked Lists
##### (9.2.1) Creating a Linked List
##### (9.2.2) Deleting a Node from a Singly Linked List
##### (9.2.3) The "Runner" Technique
##### (9.2.4) Recursive Problems
#### (9.3) Stacks and Queues
##### (9.3.1) Implementing a Stack
##### (9.3.2) Implementing a Queue
#### (9.4) Trees and Graphs
##### (9.4.1) Types of Trees
##### (9.4.2) Binary Tree Traversal
##### (9.4.3) Binary heaps (Min-Heaps and Max-Heaps)
##### (9.4.4) Tries (Prefix Trees)
##### (9.4.5) Graphs
##### (9.4.6) Graph Search
### Concepts and Algorithms
#### (9.5) Bit Manipulation
##### (9.5.1) Bit Manipulation by Hand
##### (9.5.2) Bit Facts and Tricks
##### (9.5.3) Two's Complement and Negative Numbers
##### (9.5.4) Arithmetic vs. Logical Right Shift
##### (9.5.5) Common Bit Tasks: Getting and Setting
#### (9.6) Math and Logic Puzzles
##### (9.6.1) Prime Numbers
##### (9.6.2) Probability
##### (9.6.3) Start Talking
##### (9.6.4) Develop Rules and Patterns
##### (9.6.5) Worst case Shifting
##### (9.6.6) Algorithm Approaches
#### (9.7) Object-Oriented Design
##### (9.7.1) How to Approach
##### (9.7.2) Design Patterns
#### (9.8) Recursion and Dynamic Programming
##### (9.8.1) How to Approach
##### (9.8.2) Recursive vs. Iterative Solutions
##### (9.8.3) DynamicProgramming & Memoization
#### (9.9) System Design and Scalability
##### (9.9.1) Handling the Questions
##### (9.9.2) Design: Step-By-Step
##### (9.9.3) Algorithms that Scale: Step-By-Tep
##### (9.9.4) Key Concepts
##### (9.9.5) Considerations
##### (9.9.6) There is no "perfect" system
##### (9.9.7) Example Problem
#### (9.10) Sorting and Searching
##### (9.10.1) Common Sorting Algorithms
##### (9.10.2) Searching Algorithms
#### (9.11) Testing
##### (9.11.1) What the Interviewer is Looking For
##### (9.11.2) Testing a Real World Object
##### (9.11.3) Testing a Piece of Software
##### (9.11.4) Testing a Function
##### (9.11.5) Troubleshooting Questions
### Knowledge Based
#### (9.12) C and C++
##### (9.12.1) Classes and Inheritance
##### (9.12.2) Constructors and Destructors
##### (9.12.3) Virtual Functions
##### (9.12.4) Virtual Destructor
##### (9.12.5) Default Values
##### (9.12.6) Operator Overloading
##### (9.12.7) Pointers and References
##### (9.12.8) Template
#### (9.13) Java
##### (9.13.1) How to Approach
##### (9.13.2) Overloading vs. Overriding
##### (9.13.3) Collection Framework
#### (9.14) Databases
##### (9.14.1) SQL Syntax and Variations
##### (9.14.2) Denormalized vs. Normalized Databases
##### (9.14.3) SQL Statements
##### (9.14.4) Small Database Design
##### (9.14.5) Large Database Design
#### (9.15) Threads and Locks
##### (9.15.1) Threads in Java
##### (9.15.2) Synchronization and Locks
##### (9.15.3) Deadlocks and Deadlock Prevention
### Additional Review Problems
#### (9.16) Moderate
#### (9.17) Hard
## (10) Solutions
### (10.1) Data Structures
### (10.2) Concepts and Algorithms
### (10.3) Knowledge Based
### (10.4) Additional Review Problems
## (11) Advanced Topics
### (11.1) Useful Math
### (11.2) Topological Sort
### (11.3) Dijkstra's Algorithm
### (11.4) Hash Table Collision Resolution
### (11.5) Rabin-Karp Substring Search
### (11.6) AVL Trees
### (11.7) Red-Black Trees
### (11.8) MapReduce
### (11.9) Additional Studying
## (12) Code Library
### (12.1) HashMapList<T, E>
### (12.2) TreeNode (Binary Search Tree)
### (12.3) LinkedListNode (Linked List)
### (12.4) Trie & TrieNode
## (13) Hints
### (13.1) Hints for Data Structures
### (13.2) Hints for Concepts and Algorithms
### (13.3) Hints for Knowledge-Based Questions
### (13.4) Hints for Additional Review Problems
## (14) About the Author


