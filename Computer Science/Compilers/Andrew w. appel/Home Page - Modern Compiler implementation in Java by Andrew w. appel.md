---
Source:
  - zotero://open-pdf/library/items/YKE2RPAL?page=3&annotation=9BZCU2LB
Length: "513"
Progress: "0"
tags:
  - status/incomplete
  - type/textbook
---
## Part I Fundamentals of Compilation
## (1) Introduction
### (1.1) Modules and interfaces
### (1.2) Tools and Software
### (1.3) Data structures for tree languages
## (2) Lexical Analysis
### (2.1) Lexical tokens
### (2.2) Regular expressions
### (2.3) Finite automata
### (2.4) Nondeterministic finite automata
### (2.5) Lexical-analyzer generators
## (3) Parsing
### (3.1) Context-free grammars
### (3.2) Predictive parsing
### (3.3) LR parsing
### (3.4) Using parser generators
### (3.5) Error Recovery
## (4) Abstract Syntax
### (4.1) Semantic actions
### (4.2) Abstract parse trees
### (4.3) Visitors
## (5) Semantic Analysis
### (5.1) Symbol tables
### (5.2) Type-checking MiniJava
## (6) Activation Records
### (6.1) Stack frames
### (6.2) Frames in the MiniJava compiler
## (7) Translation to Intermediate Code
### (7.1) Intermediate representation trees
### (7.2) Translation into trees
### (7.3) Declarations
## (8) Basic Blocks and Traces
### (8.1) Canonical trees
### (8.2) Taming conditional branches
## (9) Instruction Selection
### (9.1) Algorithms for instruction selection
### (9.2) CISC machines
### (9.3) Instruction selection for the MiniJava compiler
## (10) Liveness Analysis
### (10.1) Solution of dataflow equations
### (10.2) Liveness in the MiniJava compiler
## (11) Register Allocation
### (11.1) Coloring by simplification
### (11.2) Coalescing
### (11.3) Precolored nodes
### (11.4) Graph-coloring implementation
### (11.5) Register allocation for trees
## (12) Putting It All Together
## Part II Advanced Topics
## (13) Garbage Collection
### (13.1) Mark-and-sweep collection
### (13.2) Reference counts
### (13.3) Copying collection
### (13.4) Generational collection
### (13.5) Incremental collection
### (13.6) Baker's algorithm
### (13.7) Interface to the compiler
## (14) Object-Oriented Languages
### (14.1) Class extension
### (14.2) Single inheritance of data fields
### (14.3) Multiple inheritance
### (14.4) Testing class membership
### (14.5) Private fields and methods
### (14.6) Classless languages
### (14.7) Optimizing object-oriented programs
## (15) Functional Programming Languages
### (15.1) A simple functional language
### (15.2) Closures
### (15.3) Immutable variables
### (15.4) Inline expansion
### (15.5) Closure conversion
### (15.6) Efficient tail recursion
### (15.7) Lazy evaluation
## (16) Polymorphic Types
### (16.1) Parametric polymorphism
### (16.2) Polymorphic type-checking
### (16.3) Translation of polymorphic programs
### (16.4) Resolution of static overloading
## (17) Dataflow Analysis
### (17.1) Intermediate representation for flow analysis
### (17.2) Various dataflow analyses
### (17.3) Transformations using dataflow analysis
### (17.4) Speeding up dataflow analysis
### (17.5) Alias analysis
## (18) Loop Optimizations
### (18.1) Dominators
### (18.2) Loop-invariant computations
### (18.3) Induction variables
### (18.4) Array-bounds checks
### (18.5) Loop unrolling
## (19) Static Single-Assignment Form
### (19.1) Converting to SSA form
### (19.2) Efficient computation of the dominator tree
### (19.3) Optimization algorithms using SSA
### (19.4) Arrays, pointers, and memory
### (19.5) The control-dependence graph
### (19.6) Converting back from SSA form
### (19.7) A functional intermediate form
## (20) Pipelining and Scheduling
### (20.1) Loop scheduling without resource bounds
### (20.2) Resource-bounded loop pipelining
### (20.3) Branch prediction
## (21) The Memory Hierarchy
### (21.1) Cache organization
### (21.2) Cache-block alignment
### (21.3) Prefetching
### (21.4) loop interchange
### (21.5) Blocking
### (21.6) Garbage collection and the memory hierarchy
## (Appendix) MiniJava Language Reference Manual
### (A.1) Lexical Issues
### (A.2) Grammar
### (A.3) Sample Program