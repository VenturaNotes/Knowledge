---
Source:
  - https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O
Length: 24 hours, 8 minutes, 10 seconds
tags:
  - status/incomplete
  - type/playlist
---
- Complete
	- [[(1) 1. Introduction to Algorithms]]
	- [[(2) 1.1 Priori Analysis and Posteriori Testing]]
	- [[(3) 1.2 Characteristics of Algorithm]]

- Incomplete
	- [[(4) 1.3 How Write and Analyze Algorithm]]
	- [[(5) 1.4 Frequency Count Method]]
	- [[(6) 1.5.1 Time Complexity 1]]
	- [[(7) 1.5.2 Time Complexity Example 2]]
	- [[(8) 1.5.3 Time Complexity of While and if 3]]
	- [[(9) 1.6 Classes of functions]]
	- [[(10) 1.7 Compare Class of Functions]]
	- [[(11) 1.8.1 Asymptotic Notations Big Oh - Omega - Theta 1]]
	- [[(12) 1.8.2 Asymptotic Notations - Big Oh - Omega - Theta 2]]
	- [[(13) 1.9 Properties of Asymptotic Notations]]
	- [[(14) 1.10.1 Comparison of Functions 1]]
	- [[(15) 1.10.2 Comparison of Functions 2]]
	- [[(16) 1.11 Best Worst and Average Case Analysis]]
	- [[(17) 1.12 Disjoint Sets Data Structure - Weighted Union and Collapsing Find]]
	- [[(18) 2 Divide And Conquer]]
	- [[(19) 2.1.1 Recurrence Relation (T(n)= T(n-1) + 1) 1]]
	- [[(20) 2.1.2 Recurrence Relation (T(n)= T(n-1) + n) 2]]
	- [[(21) 2.1.3 Recurrence Relation (T(n)= T(n-1) + log n) 3]]
	- [[(22) 2.1.4 Recurrence Relation T(n)=2 T(n-1)+1  4]]
	- [[(23) 2.2 Masters Theorem Decreasing Function]]
	- [[(24) 2.3.1 Recurrence Relation Dividing Function T(n)=T(n and 2)+1 1]]
	- [[(25) 2.3.2 Recurrence Relation Dividing ( T(n)=T(n and 2)+ n).   2]]
	- [[(26) 2.3.3 Recurrence Relation ( T(n)= 2T(n and 2) +n)  3]]
	- [[(27) 2.4.1 Masters Theorem in Algorithms for Dividing Function 1]]
	- [[(28) 2.4.2 Examples for Master Theorem 2]]
	- [[(29) 2.5 Root function (Recurrence Relation)]]
	- [[(30) 2.6.1 Binary Search Iterative Method]]
	- [[(31) 2.6.2 Binary Search Recursive Method]]
	- [[(32) 2.6.3 Heap - Heap Sort - Heapify - Priority Queues]]
	- [[(33) 2.7.1  Two Way MergeSort - Iterative method]]
	- [[(34) 2.7.2.  Merge Sort Algorithm]]
	- [[(35) 2.7.3 MergeSort in-depth Analysis]]
	- [[(36) 2.8.1  QuickSort Algorithm]]
	- [[(37) 2.8.2 QuickSort Analysis]]
	- [[(38) 2.9 Strassens Matrix Multiplication]]
	- [[(39) 3. Greedy Method -  Introduction]]
	- [[(40) 3.1 Knapsack Problem - Greedy Method]]
	- [[(41) 3.2 Job Sequencing with Deadlines - Greedy Method]]
	- [[(42) 3.3 Optimal Merge Pattern - Greedy Method]]
	- [[(43) 3.4 Huffman Coding - Greedy Method]]
	- [[(44) 3.5 Prims and Kruskals Algorithms - Greedy Method]]
	- [[(45) 3.6 Dijkstra Algorithm - Single Source Shortest Path - Greedy Method]]
	- [[(46) 4 Principle  of Optimality  - Dynamic Programming introduction]]
	- [[(47) 4.1 MultiStage Graph - Dynamic Programming]]
	- [[(48) 4.1.1 MultiStage Graph (Program) - Dynamic Programming]]
	- [[(49) 4.2 All Pairs Shortest Path (Floyd-Warshall) - Dynamic Programming]]
	- [[(50) 4.3 Matrix Chain Multiplication - Dynamic Programming]]
	- [[(51) (New) Matrix Chain Multiplication using Dynamic Programming Formula]]
	- [[(52) 4.3.1 Matrix Chain Multiplication (Program) - Dynamic Programming]]
	- [[(53) 4.4 Bellman Ford Algorithm - Single Source Shortest Path - Dynamic Programming]]
	- [[(54) 4.5 0 and 1 Knapsack - Two Methods - Dynamic Programming]]
	- [[(55) 4.5.1 0 and 1 Knapsack Problem (Program) - Dynamic Programming]]
	- [[(56) 4.6 Optimal Binary Search Tree (Successful Search Only) - Dynamic Programming]]
	- [[(57) 4.6.2 (New) Optimal Binary Search Tree Successful and Unsuccessful Probability - Dynamic Programming]]
	- [[(58) 4.7 (New) Traveling Salesman Problem - Dynamic Programming using Formula]]
	- [[(59) 4.8 Reliability Design - Dynamic Programming]]
	- [[(60) 4.9 Longest Common Subsequence (LCS)  - Recursion and Dynamic Programming]]
	- [[(61) 5.1 Graph Traversals - BFS & DFS -Breadth First Search and Depth First Search]]
	- [[(62) 5.2 Articulation Point and Biconnected Components]]
	- [[(63) 6 Introduction to Backtracking - Brute Force Approach]]
	- [[(64) 6.1 N Queens Problem using Backtracking]]
	- [[(65) 6.2 Sum Of Subsets Problem - Backtracking]]
	- [[(66) 6.3 Graph Coloring Problem - Backtracking]]
	- [[(67) 6.4 Hamiltonian Cycle - Backtracking]]
	- [[(68) 7 Branch and Bound Introduction]]
	- [[(69) 7.1 Job Sequencing with Deadline - Branch and Bound]]
	- [[(70) 7.2 0 and 1 Knapsack using Branch and Bound]]
	- [[(71) 7.3 Traveling Salesman Problem - Branch and Bound]]
	- [[(72) 8. NP-Hard and NP-Complete Problems]]
	- [[(73) 8.1 NP-Hard Graph Problem - Clique Decision Problem]]
	- [[(74) 9.1 Knuth-Morris-Pratt KMP String Matching Algorithm]]
	- [[(75) 9.2 Rabin-Karp String Matching Algorithm]]
	- [[(76) 10.1 AVL Tree - Insertion and Rotations]]
	- [[(77) 10.2  B Trees and B+ Trees. How they are useful in Databases]]
	- [[(78) Asymptotic Notations - Simplified]]
	- [[(79) Hashing Technique - Simplified]]
	- [[(80) Shortest Path Algorithms (Dijkstra and Bellman-Ford)  - Simplified]]
	- [[(81) BFS DFS - Simplified]]
	- [[(82) Tower of Hanoi Problem - Made Easy]]
	- [[(83) Row-Major and Column-Major Mapping]]
	- [[(84) Merge Sort Algorithm - Hindi]]