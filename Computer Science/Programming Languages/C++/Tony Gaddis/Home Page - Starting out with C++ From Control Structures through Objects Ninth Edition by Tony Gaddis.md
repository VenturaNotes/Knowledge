---
Source:
  - zotero://open-pdf/library/items/BESDWAGJ?page=1&annotation=ESDKVXGG
Length: "1347"
tags:
  - status/incomplete
  - type/textbook
Progress: "0"
---
## Preface
## (1) Introduction to Computers and Programming
### (1.1) Why Program?
### (1.2) Computer Systems: Hardware and Software
### (1.3) Programs and Programming Languages
### (1.4) What Is a Program Made Of?
### (1.5) Input, Processing, and Output
### (1.6) The Programming Process
### (1.7) Procedural and Object-Oriented Programming
### (1.8) Review Questions and Exercises
## (2) Introduction to C++
### (2.1) The Parts of a C++ Program
### (2.2) The cout Object
### (2.3) The include Directive
### (2.4) Variables, Literals, and Assignment Statements
### (2.5) Identifiers
### (2.6) Integer Data Types
### (2.7) The char Data Types
### (2.8) The C++ string Class
### (2.9) Floating-Point Data Types
### (2.10) The bool Data Type
### (2.11) Determining the Size of a Data Type
### (2.12) More about Variable Assignments and Initialization
### (2.13) Scope
### (2.14) Arithmetic Operators
### (2.15) Comments
### (2.16) Named Constants
### (2.17) Programming Style
### (2.18) Review Questions and Exercises
### (2.19) Programming Challenges
## (3) Expressions and Interactivity
### (3.1) The cin Object
### (3.2) Mathematical Expressions
### (3.3) When You Mix Apples and Oranges: Type Conversion
### (3.4) Overflow and Underfolw
### (3.5) Type Casting
### (3.6) Multiple Assignment and Combined Assignment
### (3.7) Formatting Output
### (3.8) Working with Characters and string Objects
### (3.9) More Mathematical Library Functions
### (3.10) Focus on debugging: Hand Tracing a Program
### (3.11) Focus on Problem Solving: A Case Study
### (3.12) Review Questions and Exercises
### (3.13) Programming Challenges
## (4) Making Decisions
### (4.1) Relational Operators
### (4.2) The if Statement
### (4.3) Expanding the if Statement
### (4.4) The if/else Statement
### (4.5) Nested if Statements
### (4.6) The if/else if Statement
### (4.7) Flags
### (4.8) Logical Operators
### (4.9) Checking Numeric Ranges with Logical Operators
### (4.10) Menus
### (4.11) focus on Software Engineering: Validating User Input
### (4.12) Comparing Characters and Strings
### (4.13) The Conditional Operator
### (4.14) The switch Statement
### (4.15) More about Block and Variable Scope
### (4.16) Review Questions and Exercises
### (4.17) Programming Challenges
## (5) Loops and Files
### (5.1) The Increment and Decrement Operators
### (5.2) Introduction to Loops: The while Loop
### (5.3) Using the while Loop for Input Validation
### (5.4) Counters
### (5.5) The do-while Loop
### (5.6) The for Loop
### (5.7) Keeping a Running Total
### (5.8) Sentinels
### (5.9) Focus on Software Engineering: Deciding Which Loop to Use
### (5.10) Nested Loops
### (5.11) Using Files for Data Storage
### (5.12) Optional Topics: Breaking and Continuing a loop
### (5.13) Review Questions and Exercises
### (5.14) Programming Challenges
## (6) Functions
### (6.1) Focus on Software Engineering: Modular Programming
### (6.2) Defining and Calling Functions
### (6.3) Function Prototypes
### (6.4) Sending Data into a Function
### (6.5) Passing Data by Value
### (6.6) focus on Software Engineering: Using Functions in a Menu-Driven Program
### (6.7) The return Statement
### (6.8) Returning a Value from a Function
### (6.9) Returning a Boolean Value
### (6.10) Local and Global Variables
### (6.11) Static Local Variables
### (6.12) Default Arguments
### (6.13) Using Reference Variables as Parameters
### (6.14) Overloading Functions
### (6.15) The exit() Function
### (6.16) Stubs and Drivers
### (6.17) Review Questions and Exercises
### (6.18) Programming Challenges
## (7) Arrays and vectors
### (7.1) Arrays Hold Multiple Values
### (7.2) Accessing Array Elements
### (7.3) No Bounds Checking in C++
### (7.4) The Range-Based for Loop
### (7.5) Processing Array Contents
### (7.6) Focus on Software Engineering: Using Parallel Arrays
### (7.7) Arrays as Function Arguments
### (7.8) Two-Dimensional Arrays
### (7.9) Arrays with Three or More Dimensions
### (7.10) Focus on Problem Solving and Program Design: A Case Study
### (7.11) Introduction to the STL vector
### (7.12) Review Questions and Exercises
### (7.13) Programming Challenges
## (8) Searching and Sorting Arrays
### (8.1) Focus on Software Engineering: Introduction to Search Algorithms
### (8.2) Focus on Problem Solving and Program design: A Case Study
### (8.3) Focus on Software Engineering: Introduction to Sorting Algorithms
### (8.4) Focus on Problem Solving and Program Design: A Case Study
### (8.5) Sorting and Searching vectors
### (8.6) Review Questions and Exercises
### (8.7) Programming Challenges
## (9) Pointers
### (9.1) Getting the Address of a Variable
### (9.2) Pointer Variables
### (9.3) The Relationship between Arrays and Pointers
### (9.4) Pointer Arithmetic
### (9.5) Initializing Pointers
### (9.6) Comparing Pointers
### (9.7) Pointers as Function Parameters
### (9.8) Dynamic Memory Allocation
### (9.9) Returning Pointers from Functions
### (9.10) Using Smart Pointers to Avoid Memory Leaks
### (9.11) Focus on Problem Solving and Program Design: A Case Study
### (9.12) Review Questions and Exercises
### (9.13) Programming Challenges
## (10) Characters, C-Strings, and More about the string Class
### (10.1) Character Testing
### (10.2) Character Case Conversion
### (10.3) C-Strings
### (10.4) Library Functions for Working with C-Strings
### (10.5) String/Numeric Conversion Functions
### (10.6) Focus on Software Engineering: Writing Your Own C-String-Handling Functions
### (10.7) More about the C++ string Class
### (10.8) Focus on Problem Solving and Program Design: A Case Study
### (10.9) Review Questions and Exercises
### (10.10) Programming Challenges
## (11) Structured Data
### (11.1) Abstract Data Types
### (11.2) Structures
### (11.3) Accessing Structure Members
### (11.4) Initializing a Structure
### (11.5) Arrays of Structures
### (11.6) Focus on Software Engineering: Nested Structures
### (11.7) Structures as Function Arguments
### (11.8) Returning a Structure from a Function
### (11.9) Pointers to Structures
### (11.10) Focus on Software Engineering: When to use ., When to Use ->, and When to Use *
### (11.11) Enumerated Data Types
### (11.12) Review Questions and Exercises
### (11.13) Programming Challenges
## (12) Advanced File Operations
### (12.1) File Operations
### (12.2) File Output Formatting
### (12.3) Passing File Stream Objects to Functions
### (12.4) More Detailed Error Testing
### (12.5) Member Functions for Reading and Writing Files
### (12.6) Focus on Software Engineering: Working with Multiple Files
### (12.7) Binary Files
### (12.8) Creating Records with Structures
### (12.9) Random-Access Files
### (12.10) Opening a File for Both Input and Output
### (12.11) Review Questions and Exercises
### (12.12) Programming Challenges
## (13) Introduction to Classes
### (13.1) Procedural and Object-Oriented Programming
### (13.2) Introduction to Classes
### (13.3) Defining an Instance of a Class
### (13.4) Why Have Private Members?
### (13.5) Focus on Software Engineering: Separating Class Specification from Implementation
### (13.6) Inline Member Functions
### (13.7) Constructors
### (13.8) Passing Arguments to Constructors
### (13.9) Destructors
### (13.10) Overloading Constructors
### (13.11) Private Member Functions
### (13.12) Arrays of Objects
### (13.13) Focus on Problem Solving and Program Design: An OOP Case Study
### (13.14) Focus on Object-Oriented Programming: Simulating Dice with Objects
### (13.15) Focus on Object-Oriented Design: The Unified Modeling Language (UML)
### (13.16) Focus on Object-Oriented Design: Finding the Classes and Their Responsibilities
### (13.17) Review Questions and Exercises
### (13.18) Programming Challenges
## (14) More about Classes
### (14.1) Instance and Static Members
### (14.2) Friends of Classes
### (14.3) Memberwise Assignment
### (14.4) Copy Constructors
### (14.5) Operator Overloading
### (14.6) Object Conversion
### (14.7) Aggregation
### (14.8) Focus on Object-Oriented Design: Class Collaborations
### (14.9) Focus on Object-Oriented Programming: Simulating the Game of Cho-Han
### (14.10) Rvalue References and Move Semantics
### (14.11) Review Questions and Exercises
### (14.12) Programming Challenges
## (15) Inheritance, Polymorphism, and Virtual Functions
### (15.1) What Is Inheritance?
### (15.2) Protected Members and Class Access
### (15.3) Constructors and Destructors in Base and Derived Classes
### (15.4) Redefining Base Class Functions
### (15.5) Class Hierarchies
### (15.6) Polymorphism and Virtual Member Functions
### (15.7) Abstract Base Classes and Pure Virtual Functions
### (15.8) Multiple Inheritance
### (15.9) Review Questions and Exercises
### (15.10) Programming Challenges
## (16) Exceptions and Templates
### (16.1) Exceptions
### (16.2) Function Templates
### (16.3) Focus on Software Engineering: Where to Start When Defining Templates
### (16.4) Class Templates
### (16.5) Review Questions and Exercises
### (16.6) Programming Challenges
## (17) The Standard Template Library
### (17.1) Introduction to the Standard Template Library
### (17.2) STL Container and Iterator Fundamentals
### (17.3) The vector Class
### (17.4) The map, multimap, and unordered_map Classes
### (17.5) The set, multiset, and unordered_set Classes
### (17.6) Algorithms
### (17.7) Introduction to Function Objects and Lambda Expressions
### (17.8) Review Questions and Exercises
### (17.9) Programming Challenges
## (18) Linked LIsts
### (18.1) Introduction to the Linked List ADT
### (18.2) Linked List Operations
### (18.3) A Linked List Template
### (18.4) Variations of the Linked List
### (18.5) The STL list forward_list Containers
### (18.6) Review Questions and Exercises
### (18.7) Programming Challenges
## (19) Stacks and Queues
### (19.1) Introduction to the Stack ADT
### (19.2) Dynamic Stacks
### (19.3) The STL stack Container
### (19.4) Introduction to the Queue ADT
### (19.5) Dynamic Queues
### (19.6) The STL Deque and queue Containers
### (19.7) Review Questions and Exercises
### (19.8) Programming Challenges
## (20) Recursion
### (20.1) Introduction to Recursion
### (20.2) Solving Problems with Recursion
### (20.3) Focus on Problem Solving and Program Design: Solving Recursively Defined Problems
### (20.4) Focus on Problem Solving and Program Design: Solving Recursively Defined Problems
### (20.5) Focus on Problem Solving and Program Design: Recursive Linked List Operations
### (20.6) Focus on Problem Solving and Program Design: A Recursive Binary Search Function
### (20.7) The Towers of Hanoi
### (20.8) Focus on Problem Solving and Program Design: The QuickSort Algorithm
### (20.9) Exhaustive Algorithms
### (20.10) Focus on Software Engineering: Recursion versus Iteration
### (20.11) Review Questions and Exercises
### (20.12) Programming Challenges
## (21) Binary Trees
### (21.1) Definition and Applications of Binary Trees
### (21.2) Binary Search Tree Operations
### (21.3) Template Considerations for Binary Search Trees
### (21.4) Review Questions and Exercises
### (21.5) Programing Challenges
